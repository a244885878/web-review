### JavaScript 精度丢失问题及解决方案

#### 一、为什么 JavaScript 会有精度丢失问题？

JavaScript 采用 IEEE 754 双精度浮点数（64 位）格式来表示数字，导致以下情况可能出现精度丢失：

1. 十进制小数无法用二进制精确表示（如 `0.1 + 0.2 !== 0.3`）。
2. 整数超过 53 位时（如 `9007199254740992 + 1 === 9007199254740992`）。

#### 二、常见的精度问题

1. 小数计算误差

```js
console.log(0.1 + 0.2); // 0.30000000000000004
console.log(0.1 * 0.2); // 0.020000000000000004
```

由于 `0.1` 和 `0.2` 转换成二进制后是 无限循环小数，计算时就会导致误差。

2. 大整数计算误差

```js
console.log(9007199254740992 + 1); // 9007199254740992
console.log(9007199254740992 + 2); // 9007199254740994
```

`9007199254740992` 是 JavaScript 可安全整数的最大值，再加 1 后无法正确表示。

#### 三、解决方案

1. 使用 `toFixed(n)` 处理小数

`toFixed(n)` 可以保留 `n` 位小数，但返回的是字符串，需要转换回 `Number`：

```js
console.log(Number((0.1 + 0.2).toFixed(2))); // 0.3
```

##### 缺点：

- `toFixed(n)` 会四舍五入，但 浮点误差仍然存在。
- 返回 字符串，需要转换成 `Number`。

2. 通过乘法和除法规避小数误差

先放大到整数，再计算，最后缩小回去：

```js
function add(a, b) {
  let scale = Math.pow(
    10,
    Math.max(
      (a.toString().split(".")[1] || "").length,
      (b.toString().split(".")[1] || "").length
    )
  );
  return (a * scale + b * scale) / scale;
}
console.log(add(0.1, 0.2)); // 0.3
```

##### 原理：

先找到两个数小数部分的最长位数 `n`，然后乘以 `10^n` 变成整数，再计算，最后再除回来。

3. 使用 BigInt 处理大整数

适用于整数计算，不适用于小数

```js
console.log(9007199254740992n + 1n); // 9007199254740993n
console.log(9007199254740992n + 2n); // 9007199254740994n
```

##### 缺点：

- `BigInt` 不能用于浮点数计算，只能用于整数。
- `BigInt` 与 `Number` 不能混用，需要手动转换。

4. 使用 `Number.EPSILON` 进行浮点数比较

`Number.EPSILON` 代表 JavaScript 能够区分的最小浮点误差：

```js
function equal(a, b) {
  return Math.abs(a - b) < Number.EPSILON;
}
console.log(equal(0.1 + 0.2, 0.3)); // true
```

##### 适用于：

浮点数比较，避免 `0.1 + 0.2 !== 0.3`。

5. 使用 `decimal.js`、`big.js`、`bignumber.js` 等库

这些库提供了 高精度计算 方法：

```js
const Decimal = require("decimal.js");

let a = new Decimal(0.1);
let b = new Decimal(0.2);
console.log(a.plus(b).toString()); // 0.3
```

##### 适用于：

财务计算、科学计算 等高精度要求的场景。

#### 四、最佳实践总结

| 场景       | 解决方案              | 适用情况                   |
| ---------- | --------------------- | -------------------------- |
| 小数误差   | `toFixed(n)`          | 仅用于显示，可能仍然有误差 |
| 小数运算   | 先放大为整数，再计算  | 适用于 `+ - \* /`          |
| 大整数计算 | `BigInt`              | 仅适用于整数计算           |
| 浮点数比较 | `Number.EPSILON`      | 比较两个浮点数是否相等     |
| 高精度计算 | `decimal.js / big.js` | 财务计算、科学计算等       |

#### 五、总结

1. 小数误差 是因为二进制无法精确表示某些十进制数。
2. 整数超过 53 位 会出现精度问题，可使用 `BigInt` 解决。
3. 乘法 & 除法放大计算 可避免浮点精度丢失。
4. 高精度计算建议使用 `decimal.js` 之类的库，适用于财务、科学计算。

一般情况下：

- 小数计算：乘法放大后计算
- 大整数计算：用 BigInt
- 高精度需求：使用 decimal.js
