import{_ as a,c as s,o as t,ae as e}from"./chunks/framework.Cthp9TdA.js";const k=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"03_js/执行上下文和执行栈.md","filePath":"03_js/执行上下文和执行栈.md"}'),l={name:"03_js/执行上下文和执行栈.md"};function n(o,i,c,h,p,r){return t(),s("div",null,i[0]||(i[0]=[e(`<p>执行上下文 (Execution Context) 和 执行栈 (Execution Stack) 是 JavaScript 执行机制的核心概念，帮助理解代码的执行过程。</p><h4 id="_1-执行上下文-execution-context" tabindex="-1">1. 执行上下文 (Execution Context) <a class="header-anchor" href="#_1-执行上下文-execution-context" aria-label="Permalink to &quot;1. 执行上下文 (Execution Context)&quot;">​</a></h4><blockquote><p>执行上下文是 JavaScript 代码在执行时的环境。它包含了关于代码如何执行的信息。每当 JavaScript 代码被执行时，都会创建一个执行上下文，执行上下文管理着代码的执行顺序和生命周期。执行上下文分为三种类型：</p></blockquote><ul><li>全局执行上下文 (Global Execution Context): 这是最初的执行上下文，所有代码最先执行的地方。它是代码最外层的环境，并且全局作用域的 <code>this</code> 指向全局对象（在浏览器中是 <code>window</code>）。</li><li>函数执行上下文 (Function Execution Context): 每当调用一个函数时，都会为该函数创建一个新的执行上下文。它包括函数的作用域、函数的参数以及函数内部的 <code>this</code>。</li><li>Eval 执行上下文 (Eval Execution Context): 执行 <code>eval()</code> 函数时创建的执行上下文，虽然在现代 <code>JavaScript</code> 中不推荐使用。</li></ul><h5 id="每个执行上下文都会有两个重要的组成部分" tabindex="-1">每个执行上下文都会有两个重要的组成部分： <a class="header-anchor" href="#每个执行上下文都会有两个重要的组成部分" aria-label="Permalink to &quot;每个执行上下文都会有两个重要的组成部分：&quot;">​</a></h5><ul><li>变量环境 (Variable Environment): 用于存储变量、函数声明等的环境。</li><li>词法环境 (Lexical Environment): 包含了当前上下文的变量和函数声明，实际上是通过作用域链来查找变量的机制。</li></ul><h4 id="_2-执行栈-execution-stack" tabindex="-1">2. 执行栈 (Execution Stack) <a class="header-anchor" href="#_2-执行栈-execution-stack" aria-label="Permalink to &quot;2. 执行栈 (Execution Stack)&quot;">​</a></h4><blockquote><p>执行栈是 JavaScript 引擎用来管理执行上下文的栈结构。栈是一个后进先出（LIFO，Last In First Out）的数据结构。当一个执行上下文被创建时，它会被推入栈中，执行完后会从栈中弹出。</p></blockquote><p>执行栈的工作过程：</p><ol><li>执行时，首先会创建一个 全局执行上下文 并将其推入栈中。</li><li>当函数被调用时，JavaScript 会为该函数创建一个新的 函数执行上下文 并将其推入栈中。</li><li>函数执行完毕后，该函数的执行上下文会从栈中弹出，控制流返回到上一个执行上下文。</li></ol><h4 id="执行上下文的创建过程" tabindex="-1">执行上下文的创建过程： <a class="header-anchor" href="#执行上下文的创建过程" aria-label="Permalink to &quot;执行上下文的创建过程：&quot;">​</a></h4><ul><li>创建阶段：在创建执行上下文时，JavaScript 引擎会创建： <ul><li>全局环境：初始化全局对象（如 window）和 this。</li><li>函数环境：为函数的参数和声明创建变量。</li></ul></li><li>执行阶段：此阶段开始实际执行代码，按顺序执行所有代码。</li></ul><h4 id="执行上下文和执行栈的关系" tabindex="-1">执行上下文和执行栈的关系： <a class="header-anchor" href="#执行上下文和执行栈的关系" aria-label="Permalink to &quot;执行上下文和执行栈的关系：&quot;">​</a></h4><blockquote><p>执行栈中的上下文依次推进和弹出。每当一个函数被调用时，它的上下文就会推入栈中；当函数执行完毕，栈会弹出，控制权返回到之前的执行上下文。</p></blockquote><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> first</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;First&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  second</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> second</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Second&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">first</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><h5 id="执行过程" tabindex="-1">执行过程： <a class="header-anchor" href="#执行过程" aria-label="Permalink to &quot;执行过程：&quot;">​</a></h5><ol><li>全局执行上下文 被推入栈中。</li><li>调用 <code>first()</code> 函数时，first 执行上下文 被推入栈中，执行 <code>console.log(&quot;First&quot;)</code>。</li><li>调用 <code>second()</code> 函数时，second 执行上下文 被推入栈中，执行 <code>console.log(&quot;Second&quot;)</code>。</li><li><code>second()</code> 执行完毕，second 执行上下文 被弹出。</li><li><code>first()</code> 执行完毕，first 执行上下文 被弹出。</li><li>最后，全局执行上下文 被弹出，程序结束。</li></ol><h4 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h4><ul><li>执行上下文是代码执行的环境，包含了变量、函数等信息。</li><li>执行栈用于管理执行上下文，确保按照正确的顺序执行代码。</li><li>执行上下文的栈结构帮助实现了 JavaScript 的异步和函数调用机制。</li></ul>`,19)]))}const u=a(l,[["render",n]]);export{k as __pageData,u as default};
