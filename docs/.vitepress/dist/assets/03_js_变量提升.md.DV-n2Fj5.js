import{_ as i,c as a,o as n,ae as l}from"./chunks/framework.Cthp9TdA.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"03_js/变量提升.md","filePath":"03_js/变量提升.md"}'),t={name:"03_js/变量提升.md"};function e(h,s,p,k,r,o){return n(),a("div",null,s[0]||(s[0]=[l(`<h3 id="javascript-变量提升是什么" tabindex="-1">JavaScript 变量提升是什么？ <a class="header-anchor" href="#javascript-变量提升是什么" aria-label="Permalink to &quot;JavaScript 变量提升是什么？&quot;">​</a></h3><blockquote><p>变量提升（hoisting）是 JavaScript 引擎在代码执行前所做的一项预处理。它会将所有用 var 关键字声明的变量和函数声明提前到当前作用域的最前面。</p></blockquote><p><strong>简单来说，就是不管你把变量声明放在哪里，JavaScript 引擎都会把它“提升”到作用域的最前面。</strong></p><h5 id="变量提升的具体行为" tabindex="-1">变量提升的具体行为 <a class="header-anchor" href="#变量提升的具体行为" aria-label="Permalink to &quot;变量提升的具体行为&quot;">​</a></h5><ol><li>声明提升： 所有用 var 声明的变量都会被提升到作用域的最前面，但是 初始化 不会被提升。也就是说，变量在提升后，其值是 undefined。</li><li>函数声明提升： 函数声明也会被提升到作用域的最前面，并且整个函数体都会被提升。也就是说，函数可以在声明之前被调用。</li></ol><p><strong>变量提升的示例</strong></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// undefined</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(b); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// undefined</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><p>在上面的代码中：</p><ul><li>console.log(a) 能够输出 undefined，是因为变量 a 虽然在 console.log 之后声明，但由于变量提升，它已经被声明为 undefined。</li><li>函数 test 中的 console.log(b) 也能输出 undefined，因为变量 b 也被提升了。</li></ul><h5 id="变量提升需要注意的点" tabindex="-1">变量提升需要注意的点 <a class="header-anchor" href="#变量提升需要注意的点" aria-label="Permalink to &quot;变量提升需要注意的点&quot;">​</a></h5><ul><li>只有 var 声明的变量才会被提升，let 和 const 声明的变量不会被提升。</li><li>函数声明比变量声明的优先级更高，如果存在同名的变量声明和函数声明，函数声明会覆盖变量声明。</li><li>变量提升只发生在当前作用域，不会跨作用域。</li></ul><h5 id="为什么要了解变量提升" tabindex="-1">为什么要了解变量提升？ <a class="header-anchor" href="#为什么要了解变量提升" aria-label="Permalink to &quot;为什么要了解变量提升？&quot;">​</a></h5><ul><li>避免错误： 了解变量提升可以帮助你避免一些常见的 JavaScript 错误，比如在变量声明之前使用它。</li><li>写出更清晰的代码： 理解变量提升的机制，可以让你写出更清晰、可维护的代码。</li></ul>`,13)]))}const E=i(t,[["render",e]]);export{c as __pageData,E as default};
