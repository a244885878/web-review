import{_ as i,c as a,o as t,ae as n}from"./chunks/framework.Cthp9TdA.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"09_手写实现/New.md","filePath":"09_手写实现/New.md"}'),l={name:"09_手写实现/New.md"};function e(h,s,p,k,r,o){return t(),a("div",null,s[0]||(s[0]=[n(`<h4 id="new-操作符的原理" tabindex="-1">new 操作符的原理 <a class="header-anchor" href="#new-操作符的原理" aria-label="Permalink to &quot;new 操作符的原理&quot;">​</a></h4><p>在 JavaScript 中，使用 new 调用一个构造函数时，实际上会按照下面 4 个步骤执行：</p><h5 id="_1-创建一个空对象" tabindex="-1">1. 创建一个空对象 <a class="header-anchor" href="#_1-创建一个空对象" aria-label="Permalink to &quot;1. 创建一个空对象&quot;">​</a></h5><ul><li>新建一个空对象（例如：<code>let obj = {}</code>），这个对象将最终作为实例被返回。</li></ul><h5 id="_2-设置原型" tabindex="-1">2. 设置原型 <a class="header-anchor" href="#_2-设置原型" aria-label="Permalink to &quot;2. 设置原型&quot;">​</a></h5><ul><li>将该空对象的内部属性 <code>[[Prototype]]</code>（即 <code>__proto__</code>）指向构造函数的 prototype 属性。这样，创建的对象就可以通过原型链访问构造函数原型上定义的属性和方法。例如：</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">obj.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">__proto__</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>或者使用 <code>Object.create</code> 方法来完成这一步骤。</p><h5 id="_3-绑定-this-并执行构造函数" tabindex="-1">3. 绑定 this 并执行构造函数 <a class="header-anchor" href="#_3-绑定-this-并执行构造函数" aria-label="Permalink to &quot;3. 绑定 this 并执行构造函数&quot;">​</a></h5><p>使用构造函数执行代码，并将其内部的 <code>this</code> 绑定到新创建的对象上。也就是说，执行：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> result</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Constructor.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">apply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj, args);</span></span></code></pre></div><p>这一步会在新对象上添加构造函数中定义的属性和方法。</p><h5 id="_4-返回对象" tabindex="-1">4. 返回对象 <a class="header-anchor" href="#_4-返回对象" aria-label="Permalink to &quot;4. 返回对象&quot;">​</a></h5><p>如果构造函数返回的是一个对象（或函数），那么 new 表达式的结果就是该返回值；否则，忽略构造函数的返回值，返回第 1 步创建的对象。</p><p>这种机制保证了使用 new 后得到的对象不仅拥有构造函数内部初始化的属性，还能继承构造函数原型上的方法和属性。</p><h4 id="手写-new-操作符" tabindex="-1">手写 new 操作符 <a class="header-anchor" href="#手写-new-操作符" aria-label="Permalink to &quot;手写 new 操作符&quot;">​</a></h4><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> myNew</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">Constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 1. 创建一个空对象</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> obj</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 2. 将空对象的 __proto__ 指向构造函数的 prototype</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  obj.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">__proto__</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 或者： const obj = Object.create(Constructor.prototype);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 3. 执行构造函数，将 this 绑定到新对象，并传入参数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> result</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Constructor.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">apply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj, args);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 4. 如果构造函数返回对象，则返回该对象，否则返回新创建的对象</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;object&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;function&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    :</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h5 id="代码说明" tabindex="-1">代码说明 <a class="header-anchor" href="#代码说明" aria-label="Permalink to &quot;代码说明&quot;">​</a></h5><ul><li>步骤 1：我们先创建一个空对象 obj。</li><li>步骤 2：将这个空对象的 <strong>proto</strong> 指向构造函数的 prototype，从而建立原型链，使得实例可以访问构造函数原型上的属性和方法。</li><li>步骤 3：通过 <code>Constructor.apply(obj, args)</code> 执行构造函数，传入 <code>obj</code> 作为 <code>this</code>，让构造函数内部的赋值操作在这个对象上生效。</li><li>步骤 4：检查构造函数的返回值。如果返回了一个对象（或函数），则认为构造函数主动返回了一个新对象，直接使用它；否则返回我们刚刚创建的 <code>obj</code>。</li></ul><h4 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h4><p>使用 new 操作符时，JavaScript 内部会：</p><ul><li>创建新对象</li><li>建立原型链（将对象的 <code>proto</code> 指向构造函数的 <code>prototype</code>）</li><li>绑定 <code>this</code> 并执行构造函数</li><li>根据构造函数的返回值决定返回哪个对象</li></ul>`,22)]))}const E=i(l,[["render",e]]);export{c as __pageData,E as default};
