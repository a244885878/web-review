import{_ as i,c as a,o as e,ae as t}from"./chunks/framework.Cthp9TdA.js";const E=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"03_js/requestAnimationFrame.md","filePath":"03_js/requestAnimationFrame.md"}'),n={name:"03_js/requestAnimationFrame.md"};function l(h,s,p,k,r,d){return e(),a("div",null,s[0]||(s[0]=[t(`<blockquote><p><code>requestAnimationFrame</code> 是一个浏览器 API，用于在浏览器下次重绘之前请求调用一个函数来更新动画。它提供了一种高效的方式来执行动画，避免了使用 <code>setInterval</code> 或 <code>setTimeout</code> 可能导致的性能问题。</p></blockquote><h4 id="基本概念" tabindex="-1">基本概念 <a class="header-anchor" href="#基本概念" aria-label="Permalink to &quot;基本概念&quot;">​</a></h4><ul><li>动画帧： 浏览器屏幕会以一定的频率刷新，每次刷新称为一帧。通常情况下，浏览器的刷新率是 60Hz，即每秒刷新 60 次。</li><li>重绘： 当页面元素的外观发生改变时，浏览器需要重新渲染页面，这个过程称为重绘。</li><li>回调函数： <code>requestAnimationFrame</code> 接受一个回调函数作为参数，这个函数会在浏览器下次重绘之前被调用。</li></ul><h4 id="工作原理" tabindex="-1">工作原理 <a class="header-anchor" href="#工作原理" aria-label="Permalink to &quot;工作原理&quot;">​</a></h4><p><code>requestAnimationFrame</code> 的工作原理是告诉浏览器：“我希望执行一个动画，请在下次重绘之前调用我的回调函数。” 浏览器会在合适的时机调用回调函数，通常与显示器的刷新率保持一致。这样可以确保动画的流畅性，并避免不必要的重绘。</p><h5 id="语法" tabindex="-1">语法 <a class="header-anchor" href="#语法" aria-label="Permalink to &quot;语法&quot;">​</a></h5><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">requestAnimationFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(callback);</span></span></code></pre></div><ul><li><code>callback</code>：一个回调函数，会在浏览器下次重绘之前被调用。该回调函数接收一个 <code>DOMHighResTimeStamp</code> 参数，表示 <code>requestAnimationFrame</code> 开始执行的时间。</li></ul><h5 id="返回值" tabindex="-1">返回值 <a class="header-anchor" href="#返回值" aria-label="Permalink to &quot;返回值&quot;">​</a></h5><p><code>requestAnimationFrame</code> 返回一个请求 ID，可以用于取消动画：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> animationId </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">requestAnimationFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(callback);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cancelAnimationFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(animationId);</span></span></code></pre></div><h5 id="示例" tabindex="-1">示例 <a class="header-anchor" href="#示例" aria-label="Permalink to &quot;示例&quot;">​</a></h5><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> element </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;myElement&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> start </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> animate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">timestamp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">start) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    start </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> timestamp;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> progress </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> timestamp </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> start;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  element.style.transform </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`translateX(\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">progress</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> /</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}px)\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (progress </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">requestAnimationFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(animate);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">requestAnimationFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(animate);</span></span></code></pre></div><p>这个例子中，<code>animate</code> 函数会不断地更新元素的 <code>translateX</code> 属性，从而实现一个平移动画。<code>requestAnimationFrame</code> 确保动画在每次重绘之前更新，从而实现流畅的动画效果。</p><h5 id="优点" tabindex="-1">优点 <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点&quot;">​</a></h5><ul><li>高效： <code>requestAnimationFrame</code> 由浏览器优化，可以更好地利用硬件资源，避免不必要的重绘。</li><li>流畅： <code>requestAnimationFrame</code> 的回调函数通常与显示器的刷新率保持一致，从而实现流畅的动画效果。</li><li>节能： 当页面不可见时，<code>requestAnimationFrame</code> 会自动停止，从而节省电能。</li></ul><h5 id="与-setinterval-和-settimeout-的比较" tabindex="-1">与 <code>setInterval</code> 和 <code>setTimeout</code> 的比较 <a class="header-anchor" href="#与-setinterval-和-settimeout-的比较" aria-label="Permalink to &quot;与 \`setInterval\` 和 \`setTimeout\` 的比较&quot;">​</a></h5><ul><li><code>setInterval</code> 和 <code>setTimeout</code> 是基于时间的，它们的回调函数会在固定的时间间隔后执行。但是，由于浏览器的重绘时间是不确定的，因此使用 <code>setInterval</code> 或 <code>setTimeout</code> 可能导致动画卡顿或丢帧。</li></ul><ul><li><code>requestAnimationFrame</code> 是基于帧的，它的回调函数会在每次重绘之前执行。这样可以确保动画的流畅性，并避免不必要的重绘。</li></ul><h4 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h4><p><code>requestAnimationFrame</code> 是一个强大的 API，用于创建高性能的 Web 动画。它提供了一种高效、流畅、节能的方式来执行动画，是 Web 动画开发的首选。</p>`,21)]))}const c=i(n,[["render",l]]);export{E as __pageData,c as default};
