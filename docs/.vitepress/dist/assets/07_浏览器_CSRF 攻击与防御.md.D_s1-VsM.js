import{_ as i,c as e,o,ae as a}from"./chunks/framework.Cthp9TdA.js";const S=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"07_浏览器/CSRF 攻击与防御.md","filePath":"07_浏览器/CSRF 攻击与防御.md"}'),t={name:"07_浏览器/CSRF 攻击与防御.md"};function r(n,l,s,c,h,_){return o(),e("div",null,l[0]||(l[0]=[a('<h4 id="什么是-csrf-攻击" tabindex="-1">什么是 CSRF 攻击？ <a class="header-anchor" href="#什么是-csrf-攻击" aria-label="Permalink to &quot;什么是 CSRF 攻击？&quot;">​</a></h4><blockquote><p>CSRF（Cross-Site Request Forgery），即跨站请求伪造，是一种常见的网络攻击。攻击者通过诱导用户点击恶意链接，在用户不知情的情况下，以用户身份发送请求，从而执行一些非法的操作。</p></blockquote><h4 id="攻击原理" tabindex="-1">攻击原理： <a class="header-anchor" href="#攻击原理" aria-label="Permalink to &quot;攻击原理：&quot;">​</a></h4><ol><li>用户登录目标网站： 用户在浏览器中登录目标网站，获取了相应的身份验证信息（如 Cookie）。</li><li>访问恶意链接： 攻击者构造一个恶意的链接，包含指向目标网站的请求，并嵌入一些恶意参数。</li><li>浏览器发送请求： 当用户点击这个恶意链接时，浏览器会自动携带之前获取的身份验证信息，向目标网站发送请求。</li><li>目标网站执行请求： 目标网站由于无法区分该请求是用户主动发起的还是被攻击者伪造的，因此会按照请求中的参数执行相应的操作。</li></ol><h4 id="举例" tabindex="-1">举例： <a class="header-anchor" href="#举例" aria-label="Permalink to &quot;举例：&quot;">​</a></h4><p>假设用户登录了一个网上银行，攻击者构造一个链接，指向该银行的转账页面，并设置转账金额和接收账户。当用户点击这个链接时，浏览器会自动向银行发送转账请求，导致用户账户中的资金被转走。</p><h4 id="如何防御-csrf-攻击" tabindex="-1">如何防御 CSRF 攻击？ <a class="header-anchor" href="#如何防御-csrf-攻击" aria-label="Permalink to &quot;如何防御 CSRF 攻击？&quot;">​</a></h4><p>为了有效防御 CSRF 攻击，可以采用以下几种方法：</p><ol><li>验证码 <ol><li>在执行重要操作之前，要求用户输入验证码。</li><li>优点：实现简单，成本较低。</li><li>缺点：用户体验较差，容易被破解。</li></ol></li><li>双重提交 Cookie <ol><li>在表单中添加一个随机生成的 token，并将该 token 同时存储在客户端的 Cookie 和表单中。</li><li>服务端验证请求中的 token 是否与 Cookie 中的 token 一致。</li><li>优点：安全性较高，用户体验较好。</li><li>缺点：实现相对复杂。</li></ol></li><li>HTTP Referer 检查 <ol><li>验证请求的 Referer 字段，确保请求来自合法的页面。</li><li>优点：实现简单。</li><li>缺点：安全性较低，可以被伪造。</li></ol></li><li>自定义请求头 <ol><li>在请求头中添加一个自定义的属性，并将其值存储在 Session 中。</li><li>服务端验证请求头中的自定义属性是否与 Session 中的值一致。</li><li>优点：安全性较高。</li><li>缺点：实现相对复杂。</li></ol></li><li>Token 验证 <ol><li>在每次请求中都携带一个随机生成的 Token，服务端验证 Token 的有效性。</li><li>优点：安全性高，灵活性强。</li><li>缺点：实现相对复杂。</li></ol></li><li>SameSite Cookie <ol><li>设置 Cookie 的 SameSite 属性为 Strict 或 Lax，可以有效防止 CSRF 攻击。</li><li>优点：浏览器原生支持，无需额外开发。</li><li>缺点：兼容性问题。</li></ol></li></ol><h4 id="其他防护措施" tabindex="-1">其他防护措施 <a class="header-anchor" href="#其他防护措施" aria-label="Permalink to &quot;其他防护措施&quot;">​</a></h4><ul><li>最小权限原则： 对于每个用户，只授予其必要的权限。</li><li>输入验证： 对所有用户输入的数据进行严格的验证和过滤。</li><li>及时更新系统： 及时修复已知的漏洞。</li><li>安全意识教育： 教育用户提高安全意识，避免点击不明链接。</li></ul><h4 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h4><p>CSRF 攻击是一种常见的网络攻击，通过伪造用户的请求来窃取用户信息或执行恶意操作。为了防御 CSRF 攻击，我们可以采用多种方法，如验证码、双重提交 Cookie、HTTP Referer 检查、自定义请求头、Token 验证以及 SameSite Cookie 等。在实际应用中，可以根据系统的具体情况，选择一种或多种方法进行组合，以达到最佳的防护效果。</p>',13)]))}const k=i(t,[["render",r]]);export{S as __pageData,k as default};
