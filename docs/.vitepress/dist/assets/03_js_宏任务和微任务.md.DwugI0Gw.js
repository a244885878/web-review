import{_ as i,c as a,o as l,ae as t}from"./chunks/framework.Cthp9TdA.js";const d=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"03_js/宏任务和微任务.md","filePath":"03_js/宏任务和微任务.md"}'),n={name:"03_js/宏任务和微任务.md"};function h(e,s,k,p,E,r){return l(),a("div",null,s[0]||(s[0]=[t(`<blockquote><p>在 JavaScript 中，宏任务（Macrotask）和微任务（Microtask）是事件循环（Event Loop）中的两种任务类型。理解它们对理解 JavaScript 的异步执行机制非常重要。</p></blockquote><h4 id="_1-宏任务-macrotask" tabindex="-1">1. 宏任务（Macrotask） <a class="header-anchor" href="#_1-宏任务-macrotask" aria-label="Permalink to &quot;1. 宏任务（Macrotask）&quot;">​</a></h4><ul><li>定义：宏任务是事件循环中较大的任务，每次事件循环会从宏任务队列中取出一个任务执行。</li><li>常见的宏任务： <ul><li>setTimeout</li><li>setInterval</li><li>setImmediate（Node.js 环境）</li><li>I/O 操作</li><li>UI 渲染（浏览器中）</li><li>script</li><li>AJAX</li></ul></li></ul><h4 id="_2-微任务-microtask" tabindex="-1">2. 微任务（Microtask） <a class="header-anchor" href="#_2-微任务-microtask" aria-label="Permalink to &quot;2. 微任务（Microtask）&quot;">​</a></h4><ul><li>定义：微任务是更细粒度的任务，在当前任务执行结束后、下一个宏任务开始前执行。微任务优先于宏任务执行。</li><li>常见的微任务： <ul><li>Promise.then/catch/finally</li><li>queueMicrotask</li><li>MutationObserver（浏览器中）</li><li>async/await</li></ul></li></ul><h4 id="_3-执行顺序" tabindex="-1">3. 执行顺序 <a class="header-anchor" href="#_3-执行顺序" aria-label="Permalink to &quot;3. 执行顺序&quot;">​</a></h4><ul><li>单个事件循环的顺序： <ol><li>执行当前的同步代码（整体代码属于第一个宏任务）。</li><li>执行微任务队列中的所有任务。</li><li>执行一个宏任务队列中的任务。</li><li>重复步骤 2 和 3。</li></ol></li></ul><h4 id="_4-示例代码" tabindex="-1">4. 示例代码 <a class="header-anchor" href="#_4-示例代码" aria-label="Permalink to &quot;4. 示例代码&quot;">​</a></h4><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;同步代码开始&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 同步代码</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;宏任务：setTimeout&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;微任务：Promise.then&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;同步代码结束&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h5 id="输出结果" tabindex="-1">输出结果 <a class="header-anchor" href="#输出结果" aria-label="Permalink to &quot;输出结果&quot;">​</a></h5><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">同步代码开始</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">同步代码结束</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">微任务：</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.then</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">宏任务：setTimeout</span></span></code></pre></div><h5 id="原因" tabindex="-1">原因： <a class="header-anchor" href="#原因" aria-label="Permalink to &quot;原因：&quot;">​</a></h5><ol><li>同步代码优先执行，输出 同步代码开始 和 同步代码结束。</li><li>微任务队列中的 Promise.then 优先于宏任务执行，因此输出 微任务：Promise.then。</li><li>最后执行宏任务队列中的 setTimeout，输出 宏任务：setTimeout。</li></ol><h4 id="_5-补充-settimeout-和-promise-的嵌套执行顺序" tabindex="-1">5. 补充：setTimeout 和 Promise 的嵌套执行顺序 <a class="header-anchor" href="#_5-补充-settimeout-和-promise-的嵌套执行顺序" aria-label="Permalink to &quot;5. 补充：setTimeout 和 Promise 的嵌套执行顺序&quot;">​</a></h4><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;宏任务：setTimeout&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;微任务：Promise.then inside setTimeout&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;微任务：Promise.then&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><h5 id="输出结果-1" tabindex="-1">输出结果： <a class="header-anchor" href="#输出结果-1" aria-label="Permalink to &quot;输出结果：&quot;">​</a></h5><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">微任务：</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.then</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">宏任务：setTimeout</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">微任务：</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.then inside setTimeout</span></span></code></pre></div><h5 id="原因-1" tabindex="-1">原因： <a class="header-anchor" href="#原因-1" aria-label="Permalink to &quot;原因：&quot;">​</a></h5><ol><li>主线程执行完后，先清空微任务队列，输出 微任务：Promise.then。</li><li>然后执行宏任务 setTimeout 的回调，输出 宏任务：setTimeout。</li><li>再清空嵌套的微任务队列，输出 微任务：Promise.then inside setTimeout。</li></ol><h4 id="_6-总结" tabindex="-1">6. 总结 <a class="header-anchor" href="#_6-总结" aria-label="Permalink to &quot;6. 总结&quot;">​</a></h4><ul><li>微任务优先于宏任务执行。</li><li>同步代码 → 微任务 → 宏任务，依此循环。</li><li>合理使用微任务和宏任务可以优化性能，但需要注意避免阻塞主线程或过多的任务嵌套导致的性能问题。</li></ul>`,21)]))}const g=i(n,[["render",h]]);export{d as __pageData,g as default};
