import{_ as a,c as e,o as T,ae as l}from"./chunks/framework.Cthp9TdA.js";const n=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"06_http/HTTP 1.1 和 HTTP 2.0 的区别.md","filePath":"06_http/HTTP 1.1 和 HTTP 2.0 的区别.md"}'),d={name:"06_http/HTTP 1.1 和 HTTP 2.0 的区别.md"};function r(i,t,o,s,_,P){return T(),e("div",null,t[0]||(t[0]=[l('<blockquote><p>HTTP/1.1 和 HTTP/2.0 是超文本传输协议（HTTP）的不同版本，用于在 Web 浏览器和服务器之间传输数据。HTTP/2.0 是自 1999 年 HTTP/1.1 发布以来的首次重大更新，它在性能和效率方面带来了显著的改进。以下是它们之间的一些主要区别：</p></blockquote><h4 id="_1-二进制分帧-vs-文本格式" tabindex="-1">1. 二进制分帧 vs. 文本格式： <a class="header-anchor" href="#_1-二进制分帧-vs-文本格式" aria-label="Permalink to &quot;1. 二进制分帧 vs. 文本格式：&quot;">​</a></h4><ul><li>HTTP/1.1： 使用基于文本的格式传输数据，这意味着数据以人类可读的文本形式发送。虽然这使得调试更容易，但也导致了更大的数据包大小和更高的解析开销。</li><li>HTTP/2.0： 采用二进制分帧层，将所有传输的数据分割成更小的消息和帧，并以二进制格式进行编码。这种方法提高了数据传输的效率和解析的健壮性。</li></ul><h4 id="_2-多路复用-vs-串行请求" tabindex="-1">2. 多路复用 vs. 串行请求： <a class="header-anchor" href="#_2-多路复用-vs-串行请求" aria-label="Permalink to &quot;2. 多路复用 vs. 串行请求：&quot;">​</a></h4><ul><li>HTTP/1.1： 通常使用单个 TCP 连接进行请求和响应。如果需要并行请求多个资源，浏览器需要建立多个 TCP 连接，这会带来额外的开销。此外，HTTP/1.1 存在“线头阻塞”问题，即一个请求的延迟会影响后续请求的执行。</li><li>HTTP/2.0： 引入了多路复用技术，允许在单个 TCP 连接上同时发送多个请求和响应。这消除了线头阻塞问题，显著提高了并发性能和页面加载速度。</li></ul><h4 id="_3-头部压缩-vs-无压缩或简单压缩" tabindex="-1">3. 头部压缩 vs. 无压缩或简单压缩： <a class="header-anchor" href="#_3-头部压缩-vs-无压缩或简单压缩" aria-label="Permalink to &quot;3. 头部压缩 vs. 无压缩或简单压缩：&quot;">​</a></h4><ul><li>HTTP/1.1： 通常不进行头部压缩，或者使用简单的压缩方法。HTTP 头部包含大量的冗余信息，这会增加传输开销。</li><li>HTTP/2.0： 使用 HPACK 压缩算法对头部进行压缩，有效地减少了头部的大小，降低了传输开销。</li></ul><h4 id="_4-服务器推送-vs-客户端请求" tabindex="-1">4. 服务器推送 vs. 客户端请求： <a class="header-anchor" href="#_4-服务器推送-vs-客户端请求" aria-label="Permalink to &quot;4. 服务器推送 vs. 客户端请求：&quot;">​</a></h4><ul><li>HTTP/1.1： 只能由客户端发起请求，服务器被动响应。</li><li>HTTP/2.0： 允许服务器主动“推送”资源到客户端缓存，而无需客户端显式请求。这可以减少客户端的请求次数，提高页面加载速度。</li></ul><h4 id="_5-安全性" tabindex="-1">5. 安全性： <a class="header-anchor" href="#_5-安全性" aria-label="Permalink to &quot;5. 安全性：&quot;">​</a></h4><ul><li>HTTP/2.0： 虽然规范本身不强制要求使用 TLS 加密，但实际上大多数浏览器都要求 HTTP/2.0 连接必须使用 TLS 加密。这提高了数据传输的安全性。</li><li>HTTP/1.1： 可以选择使用 TLS 加密，但不是强制性的。</li></ul><h4 id="总结" tabindex="-1">总结： <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结：&quot;">​</a></h4><table tabindex="0"><thead><tr><th>特性</th><th>HTTP/1.1</th><th>HTTP/2.0</th></tr></thead><tbody><tr><td>数据格式</td><td>文本</td><td>二进制分帧</td></tr><tr><td>连接复用</td><td>串行请求</td><td>多路复用</td></tr><tr><td>头部压缩</td><td>无或简单压缩</td><td>HPACK 压缩</td></tr><tr><td>服务器推送</td><td>不支持</td><td>支持</td></tr><tr><td>安全性</td><td>可选 TLS</td><td>推荐 TLS</td></tr></tbody></table><p>总而言之，HTTP/2.0 通过引入二进制分帧、多路复用、头部压缩和服务器推送等技术，显著提高了 Web 应用程序的性能和效率。它减少了延迟，提高了带宽利用率，并增强了安全性，为用户提供了更快的 Web 体验。</p>',14)]))}const H=a(d,[["render",r]]);export{n as __pageData,H as default};
