import{_ as a,c as e,o as i,ae as d}from"./chunks/framework.Cthp9TdA.js";const p=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"07_浏览器/僵尸进程和孤儿进程是什么？.md","filePath":"07_浏览器/僵尸进程和孤儿进程是什么？.md"}'),o={name:"07_浏览器/僵尸进程和孤儿进程是什么？.md"};function r(l,t,c,s,h,n){return i(),e("div",null,t[0]||(t[0]=[d('<blockquote><p>在操作系统中，进程是资源分配的基本单位。当一个进程结束时，它通常会留下一些资源需要清理。如果清理工作没有及时完成，就会产生僵尸进程或孤儿进程。</p></blockquote><h4 id="僵尸进程-zombie-process" tabindex="-1">僵尸进程（Zombie Process） <a class="header-anchor" href="#僵尸进程-zombie-process" aria-label="Permalink to &quot;僵尸进程（Zombie Process）&quot;">​</a></h4><ul><li>定义： 一个已经终止的子进程，但其父进程还没有调用 <code>wait()</code> 或 <code>waitpid()</code> 系统调用来回收它的资源，因而让子进程的进程描述符仍然保留在系统中的特殊进程。</li><li>原因： 父进程没有及时处理子进程的退出状态。</li><li>危害： 僵尸进程虽然不再运行，但其进程描述符仍然占用系统资源，如果大量的僵尸进程存在，会影响系统的稳定性。</li></ul><h4 id="孤儿进程-orphan-process" tabindex="-1">孤儿进程（Orphan Process） <a class="header-anchor" href="#孤儿进程-orphan-process" aria-label="Permalink to &quot;孤儿进程（Orphan Process）&quot;">​</a></h4><ul><li>定义： 一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程就称为孤儿进程。</li><li>处理： 孤儿进程会被 init 进程（进程号为 1）收养，由 init 进程接管这些进程。</li><li>影响： 孤儿进程本身对系统的影响不大，因为它们会被 init 进程接管。</li></ul><h4 id="僵尸进程和孤儿进程的区别" tabindex="-1">僵尸进程和孤儿进程的区别 <a class="header-anchor" href="#僵尸进程和孤儿进程的区别" aria-label="Permalink to &quot;僵尸进程和孤儿进程的区别&quot;">​</a></h4><table tabindex="0"><thead><tr><th>特征</th><th>僵尸进程</th><th>孤儿进程</th></tr></thead><tbody><tr><td>父子进程关系</td><td>子进程已终止，父进程未回收</td><td>父进程已终止，子进程还在运行</td></tr><tr><td>进程状态</td><td>进程描述符仍在系统中</td><td>进程继续运行</td></tr><tr><td>危害</td><td>占用系统资源</td><td>对系统影响较小</td></tr><tr><td>处理方式</td><td>父进程调用 <code>wait()</code> 或 <code>waitpid()</code></td><td>被 init 进程收养</td></tr></tbody></table><h4 id="产生原因及预防" tabindex="-1">产生原因及预防 <a class="header-anchor" href="#产生原因及预防" aria-label="Permalink to &quot;产生原因及预防&quot;">​</a></h4><ul><li>僵尸进程： 父进程设计不合理，没有及时调用 <code>wait()</code> 或 <code>waitpid()</code> 系统调用。</li><li>孤儿进程： 父进程异常退出，子进程来不及处理。</li></ul><h4 id="预防措施" tabindex="-1">预防措施： <a class="header-anchor" href="#预防措施" aria-label="Permalink to &quot;预防措施：&quot;">​</a></h4><ul><li>父进程及时回收子进程： 在创建子进程后，父进程应该及时调用 <code>wait()</code> 或 <code>waitpid()</code> 系统调用来等待子进程的终止，并回收其资源。</li><li>异常处理： 对于可能出现的异常情况，比如父进程崩溃，应该有相应的处理机制，确保子进程能够被正确处理。</li><li>信号处理： 可以使用信号机制来通知父进程子进程的状态，以便父进程及时进行处理。</li></ul><h4 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h4><p>僵尸进程和孤儿进程是进程管理中常见的两种特殊情况，它们都会对系统产生一定的影响。为了避免这些问题，程序员在设计多进程程序时，应该仔细考虑进程的生命周期，并采取相应的措施来保证系统的稳定性。</p>',13)]))}const u=a(o,[["render",r]]);export{p as __pageData,u as default};
