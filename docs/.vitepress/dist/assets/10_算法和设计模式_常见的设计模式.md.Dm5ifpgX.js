import{_ as l,c as i,o as e,ae as t}from"./chunks/framework.Cthp9TdA.js";const s=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"10_算法和设计模式/常见的设计模式.md","filePath":"10_算法和设计模式/常见的设计模式.md"}'),r={name:"10_算法和设计模式/常见的设计模式.md"};function o(h,a,_,u,n,d){return e(),i("div",null,a[0]||(a[0]=[t('<h4 id="_1-单例模式" tabindex="-1">1. 单例模式 <a class="header-anchor" href="#_1-单例模式" aria-label="Permalink to &quot;1. 单例模式&quot;">​</a></h4><ul><li>原理： 保证一个类（或对象）在整个应用中只有一个实例，并提供全局访问入口。</li><li>思想： 通过延迟初始化（惰性加载）和实例缓存，避免重复创建同一对象，从而节省资源并保持状态一致。</li></ul><h4 id="_2-工厂模式" tabindex="-1">2. 工厂模式 <a class="header-anchor" href="#_2-工厂模式" aria-label="Permalink to &quot;2. 工厂模式&quot;">​</a></h4><ul><li>原理： 将对象创建的过程封装在一个单独的“工厂”中，客户端只需通过工厂接口来获取实例，而无需了解对象创建的细节。</li><li>思想： 通过解耦对象的创建与使用，使得系统具有更高的扩展性和灵活性（例如在不同情况下可以返回不同类型的对象）。</li></ul><h4 id="_3-原型模式" tabindex="-1">3. 原型模式 <a class="header-anchor" href="#_3-原型模式" aria-label="Permalink to &quot;3. 原型模式&quot;">​</a></h4><ul><li>原理： 以一个已有的对象作为原型，通过复制（克隆）的方式来创建新对象，从而实现属性和方法的共享。</li><li>思想： 利用 JavaScript 内置的原型链机制，将共享的功能封装在原型上，既节省内存，又方便扩展。</li></ul><h4 id="_4-观察者模式" tabindex="-1">4. 观察者模式 <a class="header-anchor" href="#_4-观察者模式" aria-label="Permalink to &quot;4. 观察者模式&quot;">​</a></h4><ul><li>原理： 定义一种一对多的依赖关系，使得当一个对象（被观察者）的状态发生变化时，所有依赖它的对象（观察者）都会收到通知并作出响应。</li><li>思想： 通过“发布—订阅”的方式，实现各组件之间的松耦合通信，常用于数据绑定和事件处理（如 Vue 响应式系统）。</li></ul><h4 id="_5-策略模式" tabindex="-1">5. 策略模式 <a class="header-anchor" href="#_5-策略模式" aria-label="Permalink to &quot;5. 策略模式&quot;">​</a></h4><ul><li>原理： 将一组可互换的算法封装成独立的策略，使得客户端可以在运行时根据需要选择合适的策略。</li><li>思想： 将变化的部分（具体算法）与不变的部分（算法调用）分离，便于扩展和维护，同时消除大量条件分支判断。</li></ul><h4 id="_6-代理模式" tabindex="-1">6. 代理模式 <a class="header-anchor" href="#_6-代理模式" aria-label="Permalink to &quot;6. 代理模式&quot;">​</a></h4><ul><li>原理： 通过为目标对象提供一个代理，来控制对目标对象的访问。代理可以在请求前后加入额外处理（如缓存、延迟加载、权限检查等）。</li><li>思想： 以中介方式隔离客户端和真实对象，使得在不改变目标对象接口的情况下增强其功能或控制访问。</li></ul><h4 id="_7-装饰器模式" tabindex="-1">7. 装饰器模式 <a class="header-anchor" href="#_7-装饰器模式" aria-label="Permalink to &quot;7. 装饰器模式&quot;">​</a></h4><ul><li>原理： 动态地为对象添加额外的功能，而不改变其原有的结构。</li><li>思想： 通过包装原对象，将新功能附加上去，实现功能的扩展和组合，同时保持原有行为不变。</li></ul><h4 id="_8-适配器模式" tabindex="-1">8. 适配器模式 <a class="header-anchor" href="#_8-适配器模式" aria-label="Permalink to &quot;8. 适配器模式&quot;">​</a></h4><ul><li>原理： 将一个对象的接口转换成客户期望的另一种接口，从而使原本不兼容的对象可以协同工作。</li><li>思想： 通过封装转换逻辑，屏蔽不同接口间的不匹配，达到复用现有功能和提高系统兼容性的目的。</li></ul><h4 id="_9-迭代器模式" tabindex="-1">9. 迭代器模式 <a class="header-anchor" href="#_9-迭代器模式" aria-label="Permalink to &quot;9. 迭代器模式&quot;">​</a></h4><ul><li>原理： 为聚合对象提供一种统一的方式顺序访问其内部元素，而不暴露其内部结构。</li><li>思想： 将遍历逻辑与聚合对象分离，使得无论内部数据结构如何，都可以通过统一接口进行遍历操作。</li></ul><h4 id="_10-组合模式" tabindex="-1">10. 组合模式 <a class="header-anchor" href="#_10-组合模式" aria-label="Permalink to &quot;10. 组合模式&quot;">​</a></h4><ul><li>原理： 将对象组合成树形结构来表示部分—整体的层次结构，使得客户端可以以一致的方式处理单个对象和组合对象。</li><li>思想： 通过统一接口和递归处理，简化对复杂结构的操作，方便整体管理和扩展。</li></ul><blockquote><p>这些模式的核心原理都围绕着“解耦”、“封装变化”以及“提高代码复用性和可维护性”展开。它们在 JavaScript 中往往会利用语言特性（例如函数是一等公民、原型链继承、闭包等）以更灵活的方式实现，从而满足前端开发中不断变化的业务需求。</p></blockquote>',21)]))}const b=l(r,[["render",o]]);export{s as __pageData,b as default};
