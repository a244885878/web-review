import{_ as i,c as a,o as h,ae as n}from"./chunks/framework.Cthp9TdA.js";const y=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"09_手写实现/实现数组的乱序输出.md","filePath":"09_手写实现/实现数组的乱序输出.md"}'),l={name:"09_手写实现/实现数组的乱序输出.md"};function t(k,s,p,e,r,d){return h(),a("div",null,s[0]||(s[0]=[n(`<h4 id="_1-算法原理" tabindex="-1">1. 算法原理 <a class="header-anchor" href="#_1-算法原理" aria-label="Permalink to &quot;1. 算法原理&quot;">​</a></h4><p>Fisher–Yates 洗牌算法（也称为 Knuth 洗牌算法）的基本思想是：</p><ul><li>从数组的末尾开始，依次选取当前未洗牌部分中的任一元素，然后与当前元素交换。</li><li>具体来说，设数组长度为 n，从 i = n−1 开始，每次生成一个随机下标 j（范围为 0 ~ i），将 array[i] 与 array[j] 交换。</li><li>这样处理后，最后每个元素出现在任一位置的概率均为 1/n!（即所有排列组合的概率均等）。</li></ul><h4 id="这种方法的优点在于" tabindex="-1">这种方法的优点在于： <a class="header-anchor" href="#这种方法的优点在于" aria-label="Permalink to &quot;这种方法的优点在于：&quot;">​</a></h4><ul><li>正确性：每一种排列出现的概率都是相同的，满足完全随机的要求。</li><li>效率高：时间复杂度为 O(n)（仅需遍历一次数组），空间复杂度为 O(1)。</li></ul><p>相比之下，使用 sort 配合随机数的方法（例如 <code>array.sort(() =&gt; Math.random() - 0.5)</code>）虽然代码简洁，但由于排序算法的实现和随机比较函数返回值的不确定性，往往不能保证每个排列的概率完全均等，且在某些浏览器中表现可能存在偏差</p><h4 id="_2-代码实现" tabindex="-1">2. 代码实现 <a class="header-anchor" href="#_2-代码实现" aria-label="Permalink to &quot;2. 代码实现&quot;">​</a></h4><p>下面给出使用 ES6 语法实现 Fisher–Yates 洗牌算法的示例代码：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * 使用 Fisher–Yates 洗牌算法将数组乱序</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@param</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> {Array}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> 需要乱序的数组</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@returns</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> {Array}</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> 原数组经过乱序后的结果</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> shuffle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 从最后一个元素开始依次向前遍历</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 生成一个[0, i]范围内的随机整数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">floor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">random</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 交换 array[i] 和 array[j] 的值（ES6 解构赋值）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    [array[i], array[j]] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [array[j], array[i]];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 示例</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> arr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">shuffle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arr));</span></span></code></pre></div><h4 id="_3-详细解释" tabindex="-1">3. 详细解释 <a class="header-anchor" href="#_3-详细解释" aria-label="Permalink to &quot;3. 详细解释&quot;">​</a></h4><h5 id="_1-遍历方向" tabindex="-1">1. 遍历方向 <a class="header-anchor" href="#_1-遍历方向" aria-label="Permalink to &quot;1. 遍历方向&quot;">​</a></h5><p>从数组末尾开始向前遍历可以保证：</p><ul><li>每次选中的随机下标 j 的范围是 <code>[0, i]</code>，即包括当前及之前的所有元素。</li><li>当 i 逐渐减小，尚未处理的部分也随之减少，确保每个元素都有机会被随机交换。</li></ul><h5 id="_2-随机下标的生成" tabindex="-1">2. 随机下标的生成 <a class="header-anchor" href="#_2-随机下标的生成" aria-label="Permalink to &quot;2. 随机下标的生成&quot;">​</a></h5><p>使用 <code>Math.random()</code> 生成一个 <code>[0, 1)</code> 的浮点数，再乘以 (i + 1) 后取整，得到的 j 值在区间 <code>[0, i]</code> 内均匀分布，从而保证每个元素交换的概率相同。</p><h5 id="_3-交换操作" tabindex="-1">3. 交换操作 <a class="header-anchor" href="#_3-交换操作" aria-label="Permalink to &quot;3. 交换操作&quot;">​</a></h5><p>利用 ES6 的数组解构赋值语法实现两个元素的交换，既简洁又直观。</p><h5 id="_4-结果均匀性" tabindex="-1">4. 结果均匀性 <a class="header-anchor" href="#_4-结果均匀性" aria-label="Permalink to &quot;4. 结果均匀性&quot;">​</a></h5><p>由于算法在每一步都保证了当前元素与未处理部分中任一元素交换的概率一致，经过完整的遍历后，数组中的每个排列出现的概率都是均等的（即 1/n!），从而实现了“完全乱序”的要求</p><h4 id="_4-小结" tabindex="-1">4. 小结 <a class="header-anchor" href="#_4-小结" aria-label="Permalink to &quot;4. 小结&quot;">​</a></h4><ul><li>Fisher–Yates 洗牌算法 是实现数组乱序的最佳方案之一，既能保证随机性又具有线性时间复杂度。</li><li>与使用 <code>sort</code> 配合随机比较函数的方法相比，该算法在理论上能确保每个排列出现的概率完全均等。</li><li>实际开发中，推荐直接使用 Fisher–Yates 算法来对数组进行随机打乱操作。</li></ul>`,21)]))}const o=i(l,[["render",t]]);export{y as __pageData,o as default};
