import{_ as a,c as i,o as e,ae as t}from"./chunks/framework.Cthp9TdA.js";const E=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"04_vue/vue中 为什么data属性是一个函数而不是一个对象.md","filePath":"04_vue/vue中 为什么data属性是一个函数而不是一个对象.md"}'),n={name:"04_vue/vue中 为什么data属性是一个函数而不是一个对象.md"};function l(p,s,d,h,o,k){return e(),i("div",null,s[0]||(s[0]=[t(`<blockquote><p>在 Vue 中，组件的 <code>data</code> 属性必须是一个函数而不是一个对象，这是为了确保每个组件实例都拥有独立的数据副本，防止数据污染。以下是详细的解释：</p></blockquote><h4 id="原因-防止组件实例之间共享数据-造成数据污染" tabindex="-1">原因：防止组件实例之间共享数据，造成数据污染 <a class="header-anchor" href="#原因-防止组件实例之间共享数据-造成数据污染" aria-label="Permalink to &quot;原因：防止组件实例之间共享数据，造成数据污染&quot;">​</a></h4><ul><li>对象形式的 <code>data</code>： 如果 <code>data</code> 是一个对象，那么所有组件实例将会共享同一个 <code>data</code> 对象。这意味着，如果一个组件实例修改了 <code>data</code> 中的某个属性，其他所有使用该组件的实例也会受到影响，这会导致意想不到的错误和难以调试的问题，也就是所谓的数据污染。</li></ul><p>举个例子：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> myComponent</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  template: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&lt;div&gt;{{ message }}&lt;/div&gt;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  data: {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 错误！data 是一个对象</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    message: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p>如果我们在页面上多次使用 <code>myComponent</code>，所有这些组件实例都会共享同一个 <code>message</code> 属性。如果其中一个实例修改了 <code>message</code> 的值，其他实例的 <code>message</code> 也会跟着改变。</p><ul><li>函数形式的 <code>data</code>： 如果 <code>data</code> 是一个函数，那么每次创建新的组件实例时，Vue 都会调用这个函数并返回一个全新的对象。这样，每个组件实例都拥有自己独立的数据副本，互不干扰。</li></ul><p>正确的写法：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> myComponent</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  template: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&lt;div&gt;{{ message }}&lt;/div&gt;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 正确！data 是一个函数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      message: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p>现在，每个 <code>myComponent</code> 实例都有自己独立的 <code>message</code> 属性，修改其中一个实例的 <code>message</code> 不会影响其他实例。</p><h4 id="更深入的理解" tabindex="-1">更深入的理解： <a class="header-anchor" href="#更深入的理解" aria-label="Permalink to &quot;更深入的理解：&quot;">​</a></h4><ul><li>原型和实例： 在 JavaScript 中，对象是通过构造函数创建的，每个构造函数可以 <code>new</code> 出很多个实例。每个实例都会继承原型上的方法或属性。Vue 的 <code>data</code> 数据其实是 Vue 原型上的属性，数据存在于内存当中。为了保证每个实例上的 <code>data</code> 数据的独立性，Vue 规定了 <code>data</code> 必须使用函数而不是对象。</li><li>工厂函数： 将 <code>data</code> 定义为函数，每次创建组件实例时，Vue 会调用该函数，就像调用一个“工厂”来生产新的数据对象一样。这种模式被称为“工厂函数”。</li><li>Vue 3 的变化： 虽然在 Vue 2 中，只有组件的 <code>data</code> 必须是函数，而 Vue 实例的 data 可以是对象。但在 Vue 3 中，为了保持一致性，所有 <code>data</code> 都必须是函数。</li></ul><h4 id="总结" tabindex="-1">总结： <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结：&quot;">​</a></h4><p>将 <code>data</code> 定义为函数是 Vue 为了保证组件的独立性和避免数据污染而采取的重要措施。它确保每个组件实例拥有独立的数据副本，从而避免了不必要的错误和提高了代码的可维护性。</p>`,14)]))}const r=a(n,[["render",l]]);export{E as __pageData,r as default};
