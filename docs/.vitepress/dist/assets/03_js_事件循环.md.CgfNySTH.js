import{_ as i,c as a,o as l,ae as e}from"./chunks/framework.Cthp9TdA.js";const d=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"03_js/事件循环.md","filePath":"03_js/事件循环.md"}'),t={name:"03_js/事件循环.md"};function n(h,s,k,p,o,r){return l(),a("div",null,s[0]||(s[0]=[e(`<blockquote><p>JavaScript 的事件循环（Event Loop）是处理异步任务的核心机制。它允许单线程的 JavaScript 能够处理异步操作，例如网络请求、定时器和用户交互，同时不会阻塞主线程。</p></blockquote><p>以下是事件循环的主要概念和运行机制：</p><h4 id="_1-执行栈-call-stack" tabindex="-1">1. 执行栈（Call Stack） <a class="header-anchor" href="#_1-执行栈-call-stack" aria-label="Permalink to &quot;1. 执行栈（Call Stack）&quot;">​</a></h4><ul><li>JavaScript 是单线程的，所有代码都在一个主线程上运行。</li><li>同步代码按照顺序压入执行栈中执行，执行完成后出栈。</li></ul><h4 id="_2-任务队列-task-queue-或-callback-queue" tabindex="-1">2. 任务队列（Task Queue 或 Callback Queue） <a class="header-anchor" href="#_2-任务队列-task-queue-或-callback-queue" aria-label="Permalink to &quot;2. 任务队列（Task Queue 或 Callback Queue）&quot;">​</a></h4><p>任务队列分为两类：</p><ul><li>宏任务队列（Macro Task Queue）： 包括： <ul><li>setTimeout</li><li>setInterval</li><li>setImmediate（仅 Node.js）</li><li>I/O</li><li>UI 渲染任务</li></ul></li><li>微任务队列（Micro Task Queue）： 包括： <ul><li>Promise.then、Promise.catch 和 Promise.finally</li><li>MutationObserver</li><li>queueMicrotask</li></ul></li></ul><p>微任务队列的优先级高于宏任务队列。</p><h4 id="_3-事件循环的运行机制" tabindex="-1">3. 事件循环的运行机制 <a class="header-anchor" href="#_3-事件循环的运行机制" aria-label="Permalink to &quot;3. 事件循环的运行机制&quot;">​</a></h4><p>事件循环负责协调执行栈和任务队列的关系。</p><ol><li>执行栈中的同步代码被依次执行。</li><li>遇到异步任务时，将其回调函数放入对应的任务队列。</li><li>当执行栈为空时，事件循环会优先检查微任务队列，执行其中的所有微任务。</li><li>如果微任务队列为空，事件循环会从宏任务队列中取出一个任务，将其压入执行栈并执行。</li><li>重复上述过程。</li></ol><h4 id="_4-运行顺序示例" tabindex="-1">4. 运行顺序示例 <a class="header-anchor" href="#_4-运行顺序示例" aria-label="Permalink to &quot;4. 运行顺序示例&quot;">​</a></h4><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;start&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;setTimeout&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Promise&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;end&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h5 id="运行结果" tabindex="-1">运行结果： <a class="header-anchor" href="#运行结果" aria-label="Permalink to &quot;运行结果：&quot;">​</a></h5><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">start;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">end;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">setTimeout;</span></span></code></pre></div><h5 id="解释" tabindex="-1">解释： <a class="header-anchor" href="#解释" aria-label="Permalink to &quot;解释：&quot;">​</a></h5><ol><li>console.log(&quot;start&quot;) 和 console.log(&quot;end&quot;) 是同步代码，依次执行。</li><li>setTimeout 的回调放入宏任务队列。</li><li>Promise.then 的回调放入微任务队列。</li><li>同步代码执行完毕，事件循环优先执行微任务队列，输出 Promise。</li><li>最后执行宏任务队列，输出 setTimeout。</li></ol><h4 id="_5-注意事项" tabindex="-1">5. 注意事项 <a class="header-anchor" href="#_5-注意事项" aria-label="Permalink to &quot;5. 注意事项&quot;">​</a></h4><ul><li>微任务队列在每次事件循环时都会被清空。</li><li>微任务适合处理需要尽快执行的任务，而宏任务更适合延迟性任务。</li><li>在 Node.js 和浏览器中，事件循环的实现有些细微差异，但核心原理相同。</li></ul>`,19)]))}const c=i(t,[["render",n]]);export{d as __pageData,c as default};
