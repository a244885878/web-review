import{_ as i,c as a,o as n,ae as l}from"./chunks/framework.Cthp9TdA.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"03_js/闭包.md","filePath":"03_js/闭包.md"}'),t={name:"03_js/闭包.md"};function h(e,s,p,k,r,o){return n(),a("div",null,s[0]||(s[0]=[l(`<h3 id="javascript-闭包-深入浅出" tabindex="-1">JavaScript 闭包：深入浅出 <a class="header-anchor" href="#javascript-闭包-深入浅出" aria-label="Permalink to &quot;JavaScript 闭包：深入浅出&quot;">​</a></h3><h4 id="什么是闭包" tabindex="-1">什么是闭包？ <a class="header-anchor" href="#什么是闭包" aria-label="Permalink to &quot;什么是闭包？&quot;">​</a></h4><blockquote><p>闭包（closure）是 JavaScript 中一个非常重要的概念，也是很多开发者容易混淆的地方。简单来说，闭包就是函数和其周围状态（词法环境）的引用捆绑在一起。换句话说，闭包让函数能访问它的外部作用域。</p></blockquote><h4 id="闭包的形成" tabindex="-1">闭包的形成 <a class="header-anchor" href="#闭包的形成" aria-label="Permalink to &quot;闭包的形成&quot;">​</a></h4><ul><li>函数嵌套： 当一个函数定义在另一个函数内部时，就形成了闭包。</li><li>内部函数引用外部变量： 内部函数可以访问外部函数的变量，即使外部函数已经执行完毕。</li></ul><p><strong>闭包的例子</strong></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> outerFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> innerFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(count);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> innerFunction;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myFunction </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> outerFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">myFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 1</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">myFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 2</span></span></code></pre></div><p>在这个例子中：</p><ul><li><code>outerFunction</code> 是外部函数，它定义了一个变量 <code>count</code> 和一个内部函数 <code>innerFunction</code></li><li><code>innerFunction</code> 可以访问 <code>outerFunction</code> 的变量 <code>count</code></li><li>当我们调用 <code>outerFunction</code> 时，它返回了 <code>innerFunction</code>。</li><li>即使 <code>outerFunction</code> 已经执行完毕，<code>myFunction</code> 仍然可以访问 <code>count</code>，因为 <code>myFunction</code> 是一个闭包。</li></ul><h4 id="闭包的作用" tabindex="-1">闭包的作用 <a class="header-anchor" href="#闭包的作用" aria-label="Permalink to &quot;闭包的作用&quot;">​</a></h4><ul><li>模拟私有变量： 闭包可以创建私有变量，外部无法直接访问。</li><li>实现模块化： 闭包可以帮助我们实现模块化编程。</li><li>创建回调函数： 闭包常用于创建回调函数。</li><li>柯里化： 闭包可以实现柯里化，即把接收多个参数的函数转换成一系列只接收一个参数的函数。</li></ul><h4 id="闭包的注意点" tabindex="-1">闭包的注意点 <a class="header-anchor" href="#闭包的注意点" aria-label="Permalink to &quot;闭包的注意点&quot;">​</a></h4><ul><li>内存泄漏： 如果闭包引用了过多的变量或对象，可能会导致内存泄漏。</li><li>性能影响： 闭包会占用更多的内存，可能会影响性能。</li></ul><h4 id="闭包的应用场景" tabindex="-1">闭包的应用场景 <a class="header-anchor" href="#闭包的应用场景" aria-label="Permalink to &quot;闭包的应用场景&quot;">​</a></h4><ul><li>异步编程： 闭包常用于异步编程，比如 Promise、async/await。</li><li>事件处理： 闭包可以用于事件处理，将事件处理函数与当前作用域绑定。</li><li>模块化： 闭包可以帮助我们实现模块化编程。</li></ul><h5 id="为什么闭包引用的变量得不到释放" tabindex="-1">为什么闭包引用的变量得不到释放？ <a class="header-anchor" href="#为什么闭包引用的变量得不到释放" aria-label="Permalink to &quot;为什么闭包引用的变量得不到释放？&quot;">​</a></h5><ul><li>闭包的特性： 闭包会将外部作用域的变量一直保存在内存中，以便在内部函数中继续访问。</li><li>垃圾回收机制： JavaScript 的垃圾回收机制是自动的，但它无法回收被闭包引用的变量，因为这些变量仍然被认为是活跃的。</li></ul><h5 id="如何手动释放闭包引用的变量" tabindex="-1">如何手动释放闭包引用的变量？ <a class="header-anchor" href="#如何手动释放闭包引用的变量" aria-label="Permalink to &quot;如何手动释放闭包引用的变量？&quot;">​</a></h5><p>严格来说，我们无法直接&quot;<code>手动释放</code>&quot;闭包引用的变量。 因为一旦变量被闭包引用，它就处于垃圾回收器的管理之外。</p><ol><li>及时解除引用： <ol><li>将变量设置为 null： 当不再需要闭包时，将外部变量设置为 null，断开闭包与外部变量的连接。</li><li>移除事件监听器： 如果闭包中包含事件监听器，在不需要时及时移除。</li><li>清除定时器： 如果闭包中包含定时器，在不需要时清除定时器。</li></ol></li><li>优化闭包的使用： <ol><li>减少闭包的创建： 尽量减少不必要的闭包创建，可以考虑使用其他方式实现相同的功能。</li><li>缩小闭包的作用域： 只将必要的变量传递给闭包，减少闭包引用的变量数量。</li></ol></li><li>合理设计代码结构： <ol><li>避免循环引用： 循环引用是导致内存泄漏的一个常见原因。</li><li>使用 WeakMap： WeakMap 可以存储键为对象的键值对，当对象不再被引用时，键值对会被自动删除。</li></ol></li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createCounter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建计数器</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> counter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createCounter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用计数器</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">counter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">counter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 解除引用</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">counter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 此时，count 变量仍然存在，但无法再被访问</span></span></code></pre></div><h5 id="注意" tabindex="-1">注意： <a class="header-anchor" href="#注意" aria-label="Permalink to &quot;注意：&quot;">​</a></h5><ul><li>手动设置 null 并不是立即释放内存： JavaScript 引擎会在合适的时机进行垃圾回收。</li><li>并非所有闭包都会导致内存泄漏： 只有当闭包长期存在且引用了过多的变量时，才会出现问题。</li></ul>`,23)]))}const E=i(t,[["render",h]]);export{c as __pageData,E as default};
