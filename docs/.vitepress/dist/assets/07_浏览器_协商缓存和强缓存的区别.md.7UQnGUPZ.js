import{_ as a,c as i,o as l,ae as d}from"./chunks/framework.Cthp9TdA.js";const f=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"07_浏览器/协商缓存和强缓存的区别.md","filePath":"07_浏览器/协商缓存和强缓存的区别.md"}'),o={name:"07_浏览器/协商缓存和强缓存的区别.md"};function t(c,e,r,h,n,u){return l(),i("div",null,e[0]||(e[0]=[d('<blockquote><p>浏览器缓存机制是前端优化中非常重要的一环，它可以显著提升网页加载速度，减少服务器的压力。而协商缓存和强缓存是浏览器缓存中的两种主要方式，它们各有特点。</p></blockquote><h4 id="强缓存" tabindex="-1">强缓存 <a class="header-anchor" href="#强缓存" aria-label="Permalink to &quot;强缓存&quot;">​</a></h4><ul><li>特点： 一旦资源被缓存，在有效期内，浏览器每次请求该资源时都会直接从缓存中获取，不会向服务器发送请求。</li><li>控制方式： 通过 HTTP 头部字段 <code>Cache-Control</code> 中的 <code>max-age</code> 指令来设置缓存的有效期。</li><li>优点： 减少了服务器的请求次数，提升了页面加载速度。</li><li>缺点： 如果服务器上的资源更新了，客户端在有效期内还是会使用旧的缓存资源，导致页面显示不一致。</li></ul><h4 id="协商缓存" tabindex="-1">协商缓存 <a class="header-anchor" href="#协商缓存" aria-label="Permalink to &quot;协商缓存&quot;">​</a></h4><ul><li>特点： 当强缓存失效后，浏览器会向服务器发送一个请求，请求中包含一个请求头（<code>If-Modified-Since</code> 或 <code>If-None-Match</code>），服务器会根据这个请求头来判断本地缓存是否过期，如果过期则返回新的资源，否则返回 <code>304 Not Modified</code> 状态码，告诉浏览器继续使用本地缓存。</li><li>控制方式： 通过 <code>HTTP</code> 头部字段 <code>Last-Modified</code> 或 <code>ETag</code> 来实现。</li><li>优点： 可以保证客户端始终获取到最新的资源。</li><li>缺点： 相比强缓存，会增加一次请求，稍微增加了一点网络开销。</li></ul><h4 id="两者对比" tabindex="-1">两者对比 <a class="header-anchor" href="#两者对比" aria-label="Permalink to &quot;两者对比&quot;">​</a></h4><table tabindex="0"><thead><tr><th>特点</th><th>强缓存</th><th>协商缓存</th></tr></thead><tbody><tr><td>是否向服务器发送请求</td><td>不发送</td><td>发送</td></tr><tr><td>控制方式</td><td>Cache-Control: max-age</td><td>Last-Modified/ETag</td></tr><tr><td>优点</td><td>减少服务器请求，提升速度</td><td>保证资源最新</td></tr><tr><td>缺点</td><td>可能使用过期资源</td><td>增加一次请求</td></tr></tbody></table><ul><li>强缓存 更适合那些不经常变动的静态资源，比如图片、CSS、JS 文件等。</li><li>协商缓存 更适合那些经常变动的资源，比如数据接口返回的 JSON 数据。</li></ul><h4 id="实际应用" tabindex="-1">实际应用 <a class="header-anchor" href="#实际应用" aria-label="Permalink to &quot;实际应用&quot;">​</a></h4><p>在实际开发中，我们通常会结合强缓存和协商缓存来优化页面性能：</p><ul><li>静态资源： 设置较长的 <code>max-age</code>，让浏览器长时间使用缓存。</li><li>动态资源： 使用 <code>Last-Modified</code> 或 <code>ETag</code> 来验证缓存是否有效。</li><li>特殊场景： 对于一些对实时性要求很高的资源，可以设置较短的 <code>max-age</code> 或不使用缓存。</li></ul><h4 id="注意事项" tabindex="-1">注意事项 <a class="header-anchor" href="#注意事项" aria-label="Permalink to &quot;注意事项&quot;">​</a></h4><ul><li>浏览器缓存机制比较复杂，不同浏览器实现可能略有差异。</li><li>为了更好的控制缓存，可以借助一些构建工具（如 <code>Webpack</code>）来生成带哈希值的静态资源文件名，这样每次资源更新时，文件名也会改变，强制浏览器重新下载。</li></ul><h4 id="http-缓存机制中的关键名词详细解释" tabindex="-1">HTTP 缓存机制中的关键名词详细解释 <a class="header-anchor" href="#http-缓存机制中的关键名词详细解释" aria-label="Permalink to &quot;HTTP 缓存机制中的关键名词详细解释&quot;">​</a></h4><h5 id="强缓存相关" tabindex="-1">强缓存相关： <a class="header-anchor" href="#强缓存相关" aria-label="Permalink to &quot;强缓存相关：&quot;">​</a></h5><ul><li>max-age: <ul><li>作用： 指定缓存内容的最大有效期，单位为秒。</li><li>位置： 响应头 <code>Cache-Control</code> 字段中。</li><li>举例： <code>Cache-Control: max-age=3600 </code>表示缓存内容在 <code>1</code> 小时内有效。</li><li>特点： 在 <code>max-age</code> 有效期内，浏览器直接从缓存中获取资源，不会向服务器发送请求。</li></ul></li><li>Expires: <ul><li>作用： 指定缓存过期的绝对时间。</li><li>位置： 响应头中。</li><li>特点： 功能与 <code>max-age</code> 相似，但 <code>max-age</code> 的优先级更高。由于服务器和客户端的时间可能不一致，<code>max-age</code> 比 <code>Expires</code> 更可靠。</li></ul></li></ul><h4 id="协商缓存相关" tabindex="-1">协商缓存相关： <a class="header-anchor" href="#协商缓存相关" aria-label="Permalink to &quot;协商缓存相关：&quot;">​</a></h4><ul><li>Last-Modified: <ul><li>作用： 表示资源在服务器上的最后修改时间。</li><li>位置： 响应头中。</li><li>特点： 服务器在响应中将资源的最后修改时间告诉浏览器，浏览器在下一次请求时，会将这个时间放在请求头 <code>If-Modified-Since</code> 中，服务器比较这两个时间，如果一致，则返回 <code>304 Not Modified</code>。</li></ul></li><li>If-Modified-Since: <ul><li>作用： 浏览器在请求中发送的字段，表示客户端所缓存的资源的最后修改时间。</li><li>位置： 请求头中。</li><li>特点： 服务器根据这个时间与服务器上资源的最后修改时间进行比较。</li></ul></li><li>ETag: <ul><li>作用： 一个唯一标识符，代表资源的一个版本。</li><li>位置： 响应头中。</li><li>特点： <code>ETag</code> 比 <code>Last-Modified</code> 更精确，因为它可以标识出那些内容虽然没有改变，但名称却改变了的文件。</li><li>If-None-Match: 对应 <code>ETag</code> 的请求头，浏览器在请求中发送，表示客户端缓存的资源的 <code>ETag</code>。</li></ul></li></ul><h4 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h4><ul><li>强缓存 主要通过 <code>max-age</code> 或 <code>Expires</code> 来控制缓存的有效期，在有效期内，浏览器直接使用缓存，无需向服务器发送请求。</li><li>协商缓存 主要通过 <code>Last-Modified/If-Modified-Since</code> 或 <code>ETag/If-None-Match</code> 来判断缓存是否过期。浏览器在请求时，将本地缓存的资源信息发送给服务器，服务器根据这些信息判断是否返回新的资源。</li></ul>',20)]))}const _=a(o,[["render",t]]);export{f as __pageData,_ as default};
