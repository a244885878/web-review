import{_ as i,c as a,o as l,ae as e}from"./chunks/framework.Cthp9TdA.js";const S=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"02_css/常用的 CSS 前缀有哪些？.md","filePath":"02_css/常用的 CSS 前缀有哪些？.md"}'),t={name:"02_css/常用的 CSS 前缀有哪些？.md"};function n(h,s,p,k,r,d){return l(),a("div",null,s[0]||(s[0]=[e(`<h3 id="css-前缀-浏览器兼容性的一道坎" tabindex="-1">CSS 前缀：浏览器兼容性的一道坎 <a class="header-anchor" href="#css-前缀-浏览器兼容性的一道坎" aria-label="Permalink to &quot;CSS 前缀：浏览器兼容性的一道坎&quot;">​</a></h3><blockquote><p>CSS 前缀是不同浏览器厂商为了在 CSS 标准正式制定之前，实现一些新的 CSS 特性而引入的。它们通常加在 CSS 属性名前面，以标识该属性是某个特定浏览器所支持的。</p></blockquote><h4 id="为什么需要-css-前缀" tabindex="-1">为什么需要 CSS 前缀？ <a class="header-anchor" href="#为什么需要-css-前缀" aria-label="Permalink to &quot;为什么需要 CSS 前缀？&quot;">​</a></h4><ul><li>CSS 标准化进程缓慢： 浏览器厂商为了抢占市场，往往会提前实现一些 CSS 特性，但由于标准尚未统一，因此需要加上前缀来区分。</li><li>浏览器内核不同： 不同的浏览器内核对 CSS 的解析方式也不同，因此需要不同的前缀来适配。</li></ul><h4 id="常用的-css-前缀" tabindex="-1">常用的 CSS 前缀 <a class="header-anchor" href="#常用的-css-前缀" aria-label="Permalink to &quot;常用的 CSS 前缀&quot;">​</a></h4><ul><li>-webkit-： 适用于 Safari、Chrome、Opera 等基于 WebKit 内核的浏览器。</li><li>-moz-： 适用于 Firefox 浏览器。</li><li>-ms-： 适用于 IE 浏览器。</li><li>-o-： 适用于早期版本的 Opera 浏览器。</li></ul><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 设置元素的圆角 */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.element</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  -webkit-border-radius</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* Safari 和 Chrome */</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  -moz-border-radius</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* Firefox */</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  -ms-border-radius</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* IE */</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  border-radius</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 标准写法 */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="为什么现在越来越少使用-css-前缀了" tabindex="-1">为什么现在越来越少使用 CSS 前缀了？ <a class="header-anchor" href="#为什么现在越来越少使用-css-前缀了" aria-label="Permalink to &quot;为什么现在越来越少使用 CSS 前缀了？&quot;">​</a></h4><ul><li>CSS 标准化进程加速： 随着 W3C 标准的不断完善，越来越多的 CSS 特性得到了广泛支持，浏览器厂商也更加重视标准的兼容性。</li><li>Autoprefixer 工具： Autoprefixer 是一款能够自动添加和删除 CSS 前缀的工具，大大减轻了开发者手动添加前缀的工作量。</li><li>浏览器兼容性越来越好： 现代浏览器对 CSS 的支持越来越全面，很多 CSS 特性已经不需要添加前缀了。</li></ul>`,9)]))}const c=i(t,[["render",n]]);export{S as __pageData,c as default};
