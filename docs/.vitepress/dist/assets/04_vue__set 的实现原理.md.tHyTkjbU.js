import{_ as o,c as d,o as c,ae as t}from"./chunks/framework.Cthp9TdA.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"04_vue/$set 的实现原理.md","filePath":"04_vue/$set 的实现原理.md"}'),a={name:"04_vue/$set 的实现原理.md"};function r(s,e,l,i,u,p){return c(),d("div",null,e[0]||(e[0]=[t('<blockquote><p><code>Vue.set()</code> 和 <code>this.$set()</code> 方法主要用于向响应式对象中添加属性，并确保新属性也是响应式的，从而触发视图更新。这是因为 Vue 的响应式系统在初始化时会通过 <code>Object.defineProperty</code> 遍历 <code>data</code> 中的属性，将其转换为 getter/setter，从而追踪变化。但对于动态添加的属性，<code>Vue</code> 无法在初始化时进行追踪，因此需要使用 <code>$set</code> 方法。</p></blockquote><h4 id="实现原理" tabindex="-1">实现原理: <a class="header-anchor" href="#实现原理" aria-label="Permalink to &quot;实现原理:&quot;">​</a></h4><p><code>Vue.set()</code> 和 <code>this.$set()</code> 的实现原理基本一致，最终都调用了 <code>set</code> 函数。这个 <code>set</code> 函数位于 <code>../observer/index</code> 文件中。区别在于：</p><ul><li><code>Vue.set()</code> 将 <code>set</code> 函数绑定在 <code>Vue</code> 构造函数上。</li><li><code>this.$set()</code> 将 <code>set</code> 函数绑定在 <code>Vue</code> 原型上。</li></ul><p><code>set</code> 函数接收三个参数：</p><ul><li><code>target</code>: 要操作的对象或数组。</li><li><code>key</code>: 要添加或修改的属性名或数组索引。</li><li><code>val</code>: 要设置的值。</li></ul><p>其内部实现逻辑大致如下：</p><ol><li>参数校验: 首先会检查 <code>target</code> 是否为 <code>undefined</code>、<code>null</code> 或基本数据类型，如果是则直接报错。</li><li>数组处理: 如果 <code>target</code> 是数组，并且 <code>key</code> 是一个有效的索引，则使用 <code>splice</code> 方法插入或替换元素。<code>splice</code> 方法本身会触发数组的响应式更新。</li><li>对象处理: 如果 <code>target</code> 是对象，则进行以下判断： <ul><li>如果 <code>key</code> 已经存在于 <code>target</code> 中，则直接赋值，这会触发已有属性的 <code>setter</code>，从而触发更新。</li><li>如果 <code>key</code> 不存在于 <code>target</code> 中，则使用 <code>Object.defineProperty</code> 将新属性添加到 <code>target</code> 上，并将其转换为 <code>getter/setter</code>，从而使其具有响应式特性。然后手动触发依赖更新，确保视图能够正确渲染。</li></ul></li></ol><h4 id="为什么要使用-set" tabindex="-1">为什么要使用 $set？ <a class="header-anchor" href="#为什么要使用-set" aria-label="Permalink to &quot;为什么要使用 $set？&quot;">​</a></h4><p>由于 Vue 的响应式系统是基于 <code>Object.defineProperty</code> 实现的，它只能侦测到对象在初始化时就已经存在的属性的变化。对于后面动态添加的属性，Vue 无法侦测到，也就无法触发视图更新。因此，需要使用 <code>$set</code> 方法来手动将新属性添加到对象上，并将其转换为响应式属性，从而确保视图能够正确更新。</p><h4 id="总结" tabindex="-1">总结: <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结:&quot;">​</a></h4><p><code>$set</code> 方法的本质是弥补了 Vue 响应式系统对于动态添加属性的不足。它通过 <code>splice</code> (针对数组) 或<code> Object.defineProperty</code> (针对对象) 来确保新添加的属性也具有响应式特性，从而触发视图更新。</p><h4 id="vue3-的-set" tabindex="-1">vue3 的$set <a class="header-anchor" href="#vue3-的-set" aria-label="Permalink to &quot;vue3 的$set&quot;">​</a></h4><p>在 Vue 3 中，<code>Vue.set</code> 和<code>this.$set</code> 的使用场景大大减少，但并非完全不需要。理解这一点需要先回顾 Vue 2 中为什么需要 $set。</p><p>Vue 3 使用了 <code>Proxy</code> 替代 <code>Object.defineProperty</code> 作为响应式系统的核心。<code>Proxy</code> 可以直接侦测到对象属性的添加和删除，因此在大多数情况下，你不再需要使用 <code>$set</code></p><p>何时仍然需要 $set (或类似方法):</p><p>虽然 Proxy 覆盖了绝大多数场景，但仍然存在一些特殊情况，你可能需要类似 <code>$set</code> 的方法：</p><ol><li>向 <code>Map</code>、<code>Set</code> 等原生集合类型添加属性: <code>Proxy</code> 无法直接侦测到 <code>Map</code> 和 <code>Set</code> 内部的变化。如果你使用 <code>Map</code> 或 <code>Set</code> 作为响应式数据，并且需要添加新的键值对或元素，你需要使用 <code>Map.set()</code> 或 <code>Set.add()</code> 等方法，这些方法本身会触发更新。或者，你可以使用 <code>reactive</code> 包裹一个普通对象来模拟 <code>Map</code> 或 <code>Set</code> 的行为。</li><li>避免某些极端情况下的性能问题: 在一些非常极端的情况下，例如需要深度监听一个包含大量嵌套对象的复杂数据结构，直接使用 <code>Proxy</code> 可能会带来一定的性能开销。这时，你可能需要采用更精细化的响应式控制策略，例如使用 <code>shallowReactive</code> 或 <code>shallowRef</code>，并结合一些手动更新的技巧。但这种情况非常少见，通常不需要过度关注。</li></ol><h4 id="总结-1" tabindex="-1">总结: <a class="header-anchor" href="#总结-1" aria-label="Permalink to &quot;总结:&quot;">​</a></h4><p>在绝大多数情况下，<code>Vue 3</code> 中你不再需要使用 <code>$set</code>。<code>Proxy</code> 的强大功能使得动态添加属性变得简单而自然。只有在处理原生集合类型（<code>Map</code>、<code>Set</code>）或遇到非常特殊的性能瓶颈时，你才可能需要考虑类似 <code>$set</code> 的方法。因此，可以认为 <code>$set</code> 在 <code>Vue 3</code> 中基本已被废弃，除非遇到上述特殊情况。</p><h5 id="补充说明" tabindex="-1">补充说明: <a class="header-anchor" href="#补充说明" aria-label="Permalink to &quot;补充说明:&quot;">​</a></h5><p>虽然 <code>Vue.set</code> 和 <code>this.$set</code> 在 <code>Vue 3</code> 中仍然存在（为了兼容 <code>Vue 2</code> 的代码），但它们内部的实现已经发生了变化，不再使用 <code>Object.defineProperty</code>，而是直接操作 <code>Proxy</code>。所以，即使你在 Vue 3 中使用了 <code>$set</code>，它本质上也是在利用 <code>Proxy</code> 的功能。</p>',22)]))}const _=o(a,[["render",r]]);export{h as __pageData,_ as default};
