import{_ as p,c as e,o as h,ae as t,j as s,a,t as n}from"./chunks/framework.Cthp9TdA.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"04_vue/Computed和函数的区别.md","filePath":"04_vue/Computed和函数的区别.md"}'),k={name:"04_vue/Computed和函数的区别.md"},E={tabindex:"0"};function d(l,i,r,o,u,g){return h(),e("div",null,[i[15]||(i[15]=t(`<blockquote><p><code>computed</code>（计算属性）和函数（<code>methods</code>）在 Vue 中都用于处理数据并返回结果，但它们之间存在一些关键的区别，主要体现在以下几个方面：</p></blockquote><h4 id="_1-缓存机制" tabindex="-1">1. 缓存机制： <a class="header-anchor" href="#_1-缓存机制" aria-label="Permalink to &quot;1. 缓存机制：&quot;">​</a></h4><ul><li><code>computed</code>： 具有缓存机制。只有当依赖的响应式数据发生变化时，<code>computed</code> 才会重新计算。如果依赖的数据没有变化，则会直接从缓存中读取结果，避免重复计算，提高性能。这是 <code>computed</code> 最重要的特性之一。</li><li>函数<code>（methods）</code>： 每次调用函数时都会执行函数体内的代码，无论依赖的数据是否发生变化。这意味着如果频繁调用一个复杂的函数，即使数据没有变化，也会重复执行，造成性能浪费。</li></ul><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;计数器：{{ counter }}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;计算属性结果：{{ computedValue }}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;函数计算结果：{{ methodValue }}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        counter: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    computed: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      computedValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;computedValue 被调用&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 只有 counter 变化时才会输出</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.counter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    methods: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      methodValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;methodValue 被调用&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 每次调用都会输出</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.counter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    mounted</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      setInterval</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.counter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><blockquote><p>在这个例子中，每秒 <code>counter</code> 的值会递增。你会发现 <code>computedValue</code> 的输出频率明显低于 <code>methodValue</code>，因为 <code>computedValue</code> 只在 <code>counter</code> 变化时重新计算，而 <code>methodValue</code> 每次调用都会执行。</p></blockquote><h4 id="_2-调用方式" tabindex="-1">2. 调用方式： <a class="header-anchor" href="#_2-调用方式" aria-label="Permalink to &quot;2. 调用方式：&quot;">​</a></h4>`,6)),s("ul",null,[s("li",null,[i[0]||(i[0]=s("code",null,"computed",-1)),i[1]||(i[1]=a("： 以属性的形式访问，不需要加括号。例如：")),s("code",null,n(l.computedValue),1),i[2]||(i[2]=a("。"))]),s("li",null,[i[3]||(i[3]=a("函数（")),i[4]||(i[4]=s("code",null,"methods",-1)),i[5]||(i[5]=a("）： 以函数调用的形式访问，需要加括号。例如：")),s("code",null,n(l.methodValue),1),i[6]||(i[6]=a("。"))])]),i[16]||(i[16]=t('<h4 id="_3-适用场景" tabindex="-1">3. 适用场景： <a class="header-anchor" href="#_3-适用场景" aria-label="Permalink to &quot;3. 适用场景：&quot;">​</a></h4><ul><li><code>computed</code>： 适用于需要基于现有数据计算出一个新的数据，并且需要在模板中频繁使用这个新数据的情况。由于其缓存特性，可以有效地提高性能。例如：过滤列表、格式化日期、计算总价等。</li><li>函数（<code>methods</code>）： 适用于需要执行一些特定的操作，例如事件处理、异步请求、复杂的逻辑处理等。如果不需要缓存，或者需要传递参数，则应该使用函数。</li></ul><h4 id="_4-是否可以设置值" tabindex="-1">4. 是否可以设置值： <a class="header-anchor" href="#_4-是否可以设置值" aria-label="Permalink to &quot;4. 是否可以设置值：&quot;">​</a></h4><ul><li><code>computed</code>： 默认情况下，<code>computed</code> 只能读取值（<code>getter</code>）。但也可以通过定义 <code>setter</code> 方法来实现可读写。</li><li>函数（<code>methods</code>）： 可以执行任意操作，包括修改数据。</li></ul><h4 id="总结" tabindex="-1">总结： <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结：&quot;">​</a></h4>',5)),s("table",E,[i[14]||(i[14]=s("thead",null,[s("tr",null,[s("th",null,"特性"),s("th",null,[s("code",null,"computed")]),s("th",null,[a("函数（"),s("code",null,"methods"),a("）")])])],-1)),s("tbody",null,[i[11]||(i[11]=s("tr",null,[s("td",null,"缓存"),s("td",null,"有缓存，依赖数据变化时才重新计算"),s("td",null,"无缓存，每次调用都执行")],-1)),s("tr",null,[i[10]||(i[10]=s("td",null,"调用方式",-1)),s("td",null,[i[7]||(i[7]=a("以属性形式访问（")),s("code",null,n(l.computedValue),1),i[8]||(i[8]=a("）"))]),s("td",null,[i[9]||(i[9]=a("以函数调用形式访问（")),s("code",null,n(l.methodValue)+"）",1)])]),i[12]||(i[12]=s("tr",null,[s("td",null,"适用场景"),s("td",null,"计算衍生数据，模板中频繁使用，需要提高性能"),s("td",null,"执行特定操作，事件处理，异步请求等")],-1)),i[13]||(i[13]=s("tr",null,[s("td",null,"是否可写"),s("td",null,[a("默认只读，可定义 "),s("code",null,"setter"),a(" 实现可写")]),s("td",null,"可以执行任意操作，包括修改数据")],-1))])]),i[17]||(i[17]=s("p",null,[a("总而言之，如果需要在模板中显示一个基于其他数据计算得出的值，并且希望提高性能，那么应该优先使用 "),s("code",null,"computed"),a("。如果需要执行一些特定的操作，或者需要传递参数，那么应该使用函数。")],-1))])}const m=p(k,[["render",d]]);export{c as __pageData,m as default};
