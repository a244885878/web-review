import{_ as a,c as s,o as t,ae as i}from"./chunks/framework.Cthp9TdA.js";const n=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"04_vue/vue中的.passive修饰符的作用以及应用场景.md","filePath":"04_vue/vue中的.passive修饰符的作用以及应用场景.md"}'),o={name:"04_vue/vue中的.passive修饰符的作用以及应用场景.md"};function r(v,e,_,p,c,d){return t(),s("div",null,e[0]||(e[0]=[i('<h3 id="vue-中的-passive-修饰符的作用以及应用场景" tabindex="-1">vue 中的.passive 修饰符的作用以及应用场景 <a class="header-anchor" href="#vue-中的-passive-修饰符的作用以及应用场景" aria-label="Permalink to &quot;vue 中的.passive 修饰符的作用以及应用场景&quot;">​</a></h3><h4 id="passive-这个修饰符会执行默认方法。你们可能会问-明明默认执行为什么会设置这样一个修饰符。这就要说一下这个修饰符的本意了。" tabindex="-1">passive 这个修饰符会执行默认方法。你们可能会问，明明默认执行为什么会设置这样一个修饰符。这就要说一下这个修饰符的本意了。 <a class="header-anchor" href="#passive-这个修饰符会执行默认方法。你们可能会问-明明默认执行为什么会设置这样一个修饰符。这就要说一下这个修饰符的本意了。" aria-label="Permalink to &quot;passive 这个修饰符会执行默认方法。你们可能会问，明明默认执行为什么会设置这样一个修饰符。这就要说一下这个修饰符的本意了。&quot;">​</a></h4><ul><li>浏览器只有等内核线程执行到事件监听器对应的 JavaScript 代码时，才能知道内部是否会调用<code>preventDefault</code>函数来阻止事件的默认行为，所以浏览器本身是没有办法对这种场景进行优化的。这种场景下，用户的手势事件无法快速产生，会导致页面无法快速执行滑动逻辑，从而让用户感觉到页面卡顿。</li><li>通俗点说就是每次事件产生，浏览器都会去查询一下是否有<code>preventDefault</code>阻止该次事件的默认动作。我们加上<code>passive</code>就是为了告诉浏览器，不用查询了，我们没用<code>preventDefault</code>阻止默认动作。</li><li>这里一般用在滚动监听，<code>@scroll</code>，<code>@touchmove</code> 。因为滚动监听过程中，移动每个像素都会产生一次事件，每次都使用内核线程查询 prevent 会使滑动卡顿。我们通过<code>passive</code>将内核线程查询跳过，可以大大提升滑动的流畅度。</li></ul><h4 id="注-passive-和-prevent-冲突-不能同时绑定在一个监听器上。" tabindex="-1">注：passive 和 prevent 冲突，不能同时绑定在一个监听器上。 <a class="header-anchor" href="#注-passive-和-prevent-冲突-不能同时绑定在一个监听器上。" aria-label="Permalink to &quot;注：passive 和 prevent 冲突，不能同时绑定在一个监听器上。&quot;">​</a></h4>',4)]))}const u=a(o,[["render",r]]);export{n as __pageData,u as default};
