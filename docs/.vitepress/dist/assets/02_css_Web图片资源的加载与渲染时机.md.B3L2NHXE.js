import{_ as l,c as a,o as e,ae as t}from"./chunks/framework.Cthp9TdA.js";const p=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"02_css/Web图片资源的加载与渲染时机.md","filePath":"02_css/Web图片资源的加载与渲染时机.md"}'),o={name:"02_css/Web图片资源的加载与渲染时机.md"};function r(c,i,d,s,n,_){return e(),a("div",null,i[0]||(i[0]=[t('<h3 id="浏览器渲染一个网页的过程大致如下" tabindex="-1">浏览器渲染一个网页的过程大致如下： <a class="header-anchor" href="#浏览器渲染一个网页的过程大致如下" aria-label="Permalink to &quot;浏览器渲染一个网页的过程大致如下：&quot;">​</a></h3><ol><li>解析 HTML: 构建 DOM 树。遇到<code>&lt;img&gt;</code>标签时，会发送请求加载图片。</li><li>解析 CSS: 构建 CSSOM 树。</li><li>结合 DOM 和 CSSOM: 构建渲染树。</li><li>布局: 计算每个节点的几何信息。</li><li>绘制: 将渲染树绘制到屏幕上。</li></ol><blockquote><p>图片的加载和渲染通常发生在第 3 步和第 5 步之间。 也就是说，浏览器在构建渲染树时会加载对应的图片资源，然后在绘制阶段将图片渲染到页面上。</p></blockquote><h4 id="影响图片加载与渲染的因素" tabindex="-1">影响图片加载与渲染的因素 <a class="header-anchor" href="#影响图片加载与渲染的因素" aria-label="Permalink to &quot;影响图片加载与渲染的因素&quot;">​</a></h4><ul><li>HTML 结构: <code>&lt;img&gt;</code>标签的位置、display 属性、visibility 属性等都会影响图片的加载和渲染时机。</li><li>CSS 样式: <code>background-image</code>、<code>object-fit</code>等属性会影响图片的显示方式。</li><li>JavaScript 代码: JavaScript 代码可以通过 DOM 操作来控制图片的加载和显示。</li><li>浏览器缓存: 浏览器会缓存图片，减少重复加载。</li><li>网络状况: 网络速度会影响图片的加载时间。</li></ul><h4 id="图片加载与渲染的优化" tabindex="-1">图片加载与渲染的优化 <a class="header-anchor" href="#图片加载与渲染的优化" aria-label="Permalink to &quot;图片加载与渲染的优化&quot;">​</a></h4><ul><li>懒加载: 只有当图片进入视口或即将进入视口时才加载，可以提高页面加载速度。</li><li>图片压缩: 降低图片质量，减少文件大小。</li><li>使用 webp 格式: webp 格式的图片压缩比更高。</li><li>CSS sprites: 将多个小图标合并成一张图片，减少 HTTP 请求。</li><li>iconfont: 使用字体图标，减少 HTTP 请求。</li><li>响应式图片: 根据屏幕大小加载不同尺寸的图片。</li></ul><h5 id="图片加载的特点" tabindex="-1">图片加载的特点 <a class="header-anchor" href="#图片加载的特点" aria-label="Permalink to &quot;图片加载的特点&quot;">​</a></h5><ul><li>display:none 的元素: 设置了<code>display:none</code>的元素，其内部的图片不会渲染，但会加载。</li><li>JavaScript 动态加载图片: 通过 JavaScript 动态创建的图片元素，其加载时机由 JavaScript 代码控制。</li><li>页面中多个<code>&lt;img&gt;</code>标签或样式表中的背景图片图片路径是同一个，图片只加载一次（浏览器请求资源时，都会先判断是否有缓存，若有缓存且未过期则会从缓存中读取，不会再次请求。先加载的图片会存储到浏览器缓存中，后面再次请求同路径图片时会直接读取缓存中的图片。）</li><li>不存在元素的背景图片不会加载（不存在的元素不会产出到 DOM 树上，构建渲染树过程中遍历 DOM 树时无法遍历不存在的元素，因此不会加载图片，也不会产出到渲染树上。当解析渲染树时无法解析不存在的元素，不存在的元素自然也不会渲染。）</li><li>当触发伪类的时候，伪类样式上的背景图片才会加载。</li></ul><h5 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h5><p>图片的加载和渲染是网页性能优化中非常重要的一环。通过了解图片加载的原理和优化方法，可以有效提高网页的加载速度和用户体验。</p>',11)]))}const u=l(o,[["render",r]]);export{p as __pageData,u as default};
