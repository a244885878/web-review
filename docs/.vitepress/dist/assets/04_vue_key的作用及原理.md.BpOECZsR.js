import{_ as i,c as a,o as e,ae as l}from"./chunks/framework.Cthp9TdA.js";const r=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"04_vue/key的作用及原理.md","filePath":"04_vue/key的作用及原理.md"}'),n={name:"04_vue/key的作用及原理.md"};function t(k,s,h,p,d,o){return e(),a("div",null,s[0]||(s[0]=[l(`<blockquote><p>在 Vue 中，key 是一个用于标识 Vue 中虚拟 DOM 的特殊属性，主要用于优化渲染和更新过程，特别是在有列表渲染的情况下。通过理解 key 的作用及其原理，可以帮助我们更高效地控制 Vue 的渲染行为。</p></blockquote><h4 id="key-的作用" tabindex="-1">key 的作用 <a class="header-anchor" href="#key-的作用" aria-label="Permalink to &quot;key 的作用&quot;">​</a></h4><h5 id="_1-帮助-vue-识别元素的唯一性" tabindex="-1">1. 帮助 Vue 识别元素的唯一性： <a class="header-anchor" href="#_1-帮助-vue-识别元素的唯一性" aria-label="Permalink to &quot;1. 帮助 Vue 识别元素的唯一性：&quot;">​</a></h5><ul><li><code>key</code> 在 Vue 的虚拟 DOM 中起到了帮助组件和元素<strong>唯一标识</strong>的作用。每当一个元素或组件发生更新时，Vue 会根据 <code>key</code> 来追踪每个节点的身份。如果没有 <code>key</code>，Vue 会依赖节点的顺序进行判断，容易造成不必要的 <code>DOM</code> 操作。</li><li>在列表渲染时（例如使用 <code>v-for</code>），如果没有 <code>key</code>，Vue 会重新渲染整个列表并进行对比，而如果有 <code>key</code>，它会通过 <code>key</code> 来进行高效的增删改操作。</li></ul><h5 id="_2-优化-dom-的更新" tabindex="-1">2. 优化 DOM 的更新： <a class="header-anchor" href="#_2-优化-dom-的更新" aria-label="Permalink to &quot;2. 优化 DOM 的更新：&quot;">​</a></h5><ul><li>在列表渲染中，<code>key</code> 帮助 Vue 确定哪些元素是新增的，哪些元素是删除的，哪些元素的位置发生了变化。这样，Vue 可以最小化对 <code>DOM</code> 的操作，避免不必要的元素重新渲染，提高性能。</li></ul><h5 id="_3-防止缓存的组件状态混淆" tabindex="-1">3. 防止缓存的组件状态混淆： <a class="header-anchor" href="#_3-防止缓存的组件状态混淆" aria-label="Permalink to &quot;3. 防止缓存的组件状态混淆：&quot;">​</a></h5><ul><li>当 <code>key</code> 被用于组件时，它告诉 Vue 当组件 <code>key</code> 改变时需要销毁当前的组件实例，并重新创建一个新的组件实例。这对于有状态的组件（例如表单或输入框）尤为重要，避免了组件的状态与其数据混淆。</li></ul><h4 id="key-的原理" tabindex="-1">key 的原理 <a class="header-anchor" href="#key-的原理" aria-label="Permalink to &quot;key 的原理&quot;">​</a></h4><p>当 Vue 渲染一个列表时，它需要对比当前的虚拟 <code>DOM</code> 和更新后的虚拟 <code>DOM</code>。没有 <code>key</code> 的话，Vue 会根据节点的顺序和位置来进行对比更新。然而，<code>DOM</code> 中的节点顺序可能发生变化，或者有节点被删除或者插入，Vue 需要尽量保留尽可能多的现有 <code>DOM</code> 节点以提高性能。</p><ul><li><strong>没有 key 的情况</strong>：Vue 会通过“就地复用”策略，逐一比较每个节点，并在无法复用时销毁并重建相应的 DOM 元素。这种做法性能较差，尤其在列表项顺序变化较大时，容易导致很多不必要的 DOM 操作。</li><li><strong>有 key 的情况</strong>：Vue 会根据 <code>key</code> 值来进行精确的元素匹配。如果一个元素的 <code>key</code> 与之前的 <code>key</code> 一致，Vue 会复用该元素的 <code>DOM</code>；如果 <code>key</code> 不同，Vue 会销毁该元素并重新创建。这允许 Vue 更高效地更新列表，并避免因位置变化导致的错误重排。</li></ul><h4 id="具体例子" tabindex="-1">具体例子 <a class="header-anchor" href="#具体例子" aria-label="Permalink to &quot;具体例子&quot;">​</a></h4><p>假设有一个列表，元素的顺序发生了变化。看看有无 <code>key</code> 对比的效果：</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!-- 没有 key --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;app&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> v-for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;item in items&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;{{ item.name }}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Vue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    el: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;#app&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    data: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      items: [{ name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;A&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }, { name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;B&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }, { name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;C&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    mounted</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.items </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [{ name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;C&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }, { name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;A&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }, { name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;B&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>在没有 <code>key</code> 的情况下，当 <code>items</code> 数组中的顺序发生变化时，Vue 会重新渲染整个列表，导致性能下降。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!-- 有 key --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;app&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> v-for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;item in items&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> :key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;item.name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;{{ item.name }}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>加上 <code>key</code> 后，Vue 会更智能地识别每个 <code>li</code> 的身份，当顺序变化时，只会重新排列 <code>DOM</code> 元素，而不会销毁和重建所有元素。</p><h4 id="key-的选择和注意事项" tabindex="-1">key 的选择和注意事项 <a class="header-anchor" href="#key-的选择和注意事项" aria-label="Permalink to &quot;key 的选择和注意事项&quot;">​</a></h4><ol><li>唯一性： <code>key</code> 的值必须是唯一的，以便 Vue 可以准确地识别每个节点。在列表中，通常使用数组元素的唯一标识符（如 <code>ID</code> 或 <code>UUID</code>）作为 <code>key</code> 值。</li><li>性能考量： <ul><li>如果 <code>key</code> 是动态生成的，并且能够保证每个元素的唯一性，这有助于提升渲染性能。</li><li>不要随便使用索引作为 <code>key</code>，尤其是在列表项的顺序可能发生变化时。因为如果使用索引，Vue 会依赖索引值来进行虚拟 <code>DOM</code> 更新，容易导致渲染问题，尤其是列表项的增删或排序操作时。</li></ul></li><li>与组件的配合： 当 <code>key</code> 应用于组件时，每次 <code>key</code> 发生变化，Vue 会销毁并重新创建组件实例，这对于保持组件的状态非常重要。例如，如果你有一个输入框组件，并希望每次重新排序时清空输入框内容，可以通过改变 <code>key</code> 来强制 Vue 销毁并重建该组件。</li></ol><h4 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h4><p><code>key</code> 是 Vue 在虚拟 DOM 中优化更新过程的重要工具。通过唯一标识元素或组件，Vue 能够更高效地比较新旧虚拟 DOM，避免不必要的 DOM 操作。正确使用 <code>key</code> 能显著提升性能，尤其在渲染大列表或动态组件时。</p><h4 id="和虚拟-dom-的关系" tabindex="-1">和虚拟 dom 的关系 <a class="header-anchor" href="#和虚拟-dom-的关系" aria-label="Permalink to &quot;和虚拟 dom 的关系&quot;">​</a></h4><p><code>key</code> 和 虚拟 <code>DOM</code> 的 <code>diff</code> 算法 是密切相关的。为了更好地理解它们之间的关系，我们需要先简要回顾一下 Vue 是如何使用虚拟 <code>DOM</code> 和 <code>diff</code> 算法来高效更新视图的。</p><ul><li><strong>虚拟 DOM</strong>：Vue 使用虚拟 DOM 来减少直接操作真实 DOM 的开销。虚拟 DOM 是一个轻量级的 JavaScript 对象，表示了视图的结构。当数据发生变化时，Vue 会生成一个新的虚拟 DOM，然后与旧的虚拟 DOM 进行对比，找到两者之间的差异（diff），并根据差异更新真实 DOM。</li><li><strong>diff 算法</strong>：Vue 使用一种高效的算法来对比新旧虚拟 DOM 之间的差异。这种算法通过以下策略来减少对 DOM 的操作： <ul><li><strong>分层比较</strong>：Vue 会对比两棵虚拟 DOM 树，首先比较根节点，然后递归地比较每个子节点。</li><li><strong>最小化操作</strong>：Vue 会尽量只更新那些发生变化的部分，避免整个树的重渲染。</li><li><strong>就地复用</strong>：如果子节点的类型和结构不变，Vue 会尝试复用该节点，而不是销毁并重新创建。</li></ul></li></ul><h5 id="key-在-diff-算法中的作用" tabindex="-1">key 在 diff 算法中的作用 <a class="header-anchor" href="#key-在-diff-算法中的作用" aria-label="Permalink to &quot;key 在 diff 算法中的作用&quot;">​</a></h5><p>当 Vue 渲染一个列表时（例如使用 <code>v-for</code> 渲染多个相似的元素），<code>key</code> 属性帮助 Vue 精确地识别每个节点，并对比新旧虚拟 <code>DOM</code> 时做出优化。没有 <code>key</code> 时，Vue 会依赖节点的顺序进行比较，但这可能导致性能问题。<code>key</code> 的引入则大大改善了这个问题。</p><p>当我们在列表中使用 <code>key</code> 属性时，Vue 的 <code>diff</code> 算法变得更加高效，能够根据 <code>key</code> 值对节点进行精确匹配。具体来说：</p><ul><li><strong>高效的更新</strong>：每个带有 <code>key</code> 的节点都可以唯一标识，Vue 会通过 <code>key</code> 来追踪每个节点的身份。当顺序发生变化时，Vue 能够识别出哪些节点只是位置改变，哪些节点是新增的，哪些节点是删除的，避免了不必要的 DOM 操作。</li><li><strong>减少节点的重建</strong>：如果 <code>key</code> 保持不变，Vue 会保持原有节点的状态，不会重新渲染组件或元素，这显著提升了性能。</li></ul>`,28)]))}const c=i(n,[["render",t]]);export{r as __pageData,c as default};
