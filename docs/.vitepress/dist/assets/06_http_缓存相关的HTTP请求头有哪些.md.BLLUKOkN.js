import{_ as l,c as i,o as a,ae as o}from"./chunks/framework.Cthp9TdA.js";const _=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"06_http/缓存相关的HTTP请求头有哪些.md","filePath":"06_http/缓存相关的HTTP请求头有哪些.md"}'),d={name:"06_http/缓存相关的HTTP请求头有哪些.md"};function c(t,e,r,h,n,u){return a(),i("div",null,e[0]||(e[0]=[o('<h4 id="http-缓存的原理与作用" tabindex="-1">HTTP 缓存的原理与作用 <a class="header-anchor" href="#http-缓存的原理与作用" aria-label="Permalink to &quot;HTTP 缓存的原理与作用&quot;">​</a></h4><blockquote><p>HTTP 缓存机制是浏览器为了提高网页加载速度而采用的优化技术。它通过在客户端存储资源的副本，减少对服务器的请求次数，从而缩短页面加载时间，提升用户体验。</p></blockquote><h4 id="缓存的两种类型" tabindex="-1">缓存的两种类型： <a class="header-anchor" href="#缓存的两种类型" aria-label="Permalink to &quot;缓存的两种类型：&quot;">​</a></h4><ul><li>强缓存: 浏览器直接从缓存中读取资源，不向服务器发送请求。</li><li>对比缓存: 浏览器向服务器发送请求，服务器根据请求头中的信息判断资源是否需要更新。</li></ul><h4 id="关键的请求头" tabindex="-1">关键的请求头 <a class="header-anchor" href="#关键的请求头" aria-label="Permalink to &quot;关键的请求头&quot;">​</a></h4><h5 id="请求头" tabindex="-1">请求头 <a class="header-anchor" href="#请求头" aria-label="Permalink to &quot;请求头&quot;">​</a></h5><ul><li><code>Cache-Control</code>: <ul><li><code>no-cache</code>: 每次请求都必须向服务器验证缓存是否有效。</li><li><code>no-store</code>: 禁止任何存储，包括中间代理服务器。</li><li><code>max-age=seconds</code>: 缓存内容的最大有效时长，超过此时间后必须重新验证。</li><li><code>public</code>: 响应可以被任何缓存。</li><li><code>private</code>: 响应只能被单个用户缓存。</li><li><code>must-revalidate</code>: 缓存失效后必须向服务器重新验证。</li><li><code>proxy-revalidate</code>: 代理缓存失效后必须向服务器重新验证。</li></ul></li><li><code>If-Modified-Since</code>: <ul><li>客户端向服务器发送请求时，携带上次获取资源的时间戳。</li><li>服务器根据该时间戳与服务器上资源的最后修改时间进行比较，如果资源未修改，则返回 <code>304 Not Modified</code>。</li></ul></li><li><code>If-None-Match</code>: <ul><li>客户端向服务器发送请求时，携带一个 <code>ETag</code> 值。</li><li><code>ETag</code> 是服务器生成的唯一标识符，表示资源的版本。</li><li>服务器根据请求头中的 <code>ETag</code> 与服务器上资源的 <code>ETag</code> 进行比较，如果一致，则返回 <code>304 Not Modified</code>。</li></ul></li></ul><h5 id="响应头" tabindex="-1">响应头 <a class="header-anchor" href="#响应头" aria-label="Permalink to &quot;响应头&quot;">​</a></h5><ul><li><code>Expires</code>: <ul><li>指定资源的过期时间。</li><li>超过该时间后，浏览器会认为缓存失效，再次向服务器发起请求。</li></ul></li><li><code>Last-Modified</code>: <ul><li>指示资源最后一次修改的时间。</li><li>与 <code>If-Modified-Since</code> 配合使用。</li></ul></li><li><code>ETag</code>: <ul><li>资源的唯一标识符，与 <code>If-None-Match</code> 配合使用。</li></ul></li><li><code>Cache-Control</code>: <ul><li>与请求头的 <code>Cache-Control</code> 作用类似，用于控制服务器端的缓存行为。</li></ul></li></ul><h4 id="缓存过程示例" tabindex="-1">缓存过程示例 <a class="header-anchor" href="#缓存过程示例" aria-label="Permalink to &quot;缓存过程示例&quot;">​</a></h4><h5 id="_1-首次请求" tabindex="-1">1. 首次请求: <a class="header-anchor" href="#_1-首次请求" aria-label="Permalink to &quot;1. 首次请求:&quot;">​</a></h5><ul><li>浏览器向服务器请求资源。</li><li>服务器返回资源，并在响应头中设置 <code>Expires、Last-Modified、ETag</code> 等信息。</li><li>浏览器将资源存储在本地缓存中。</li></ul><h5 id="_2-后续请求" tabindex="-1">2. 后续请求: <a class="header-anchor" href="#_2-后续请求" aria-label="Permalink to &quot;2. 后续请求:&quot;">​</a></h5><ul><li>浏览器再次请求该资源时，会携带 <code>If-Modified-Since</code> 或 <code>If-None-Match</code> 头。</li><li>服务器比较请求头中的信息与服务器端存储的信息，如果资源未修改，则返回 <code>304 Not Modified</code>，浏览器直接使用本地缓存。</li></ul><h5 id="缓存控制策略" tabindex="-1">缓存控制策略 <a class="header-anchor" href="#缓存控制策略" aria-label="Permalink to &quot;缓存控制策略&quot;">​</a></h5><ul><li>强缓存 <ul><li>浏览器直接使用本地缓存，不向服务器发送请求。</li><li>常用的 <code>Cache-Control</code> 指令：<code>max-age</code></li></ul></li><li>协商缓存: <ul><li>浏览器向服务器发送请求，服务器根据请求头中的信息判断资源是否需要更新。</li><li>常用的请求头：<code>If-Modified-Since</code>、<code>If-None-Match</code></li></ul></li></ul><h4 id="实际应用中的注意事项" tabindex="-1">实际应用中的注意事项 <a class="header-anchor" href="#实际应用中的注意事项" aria-label="Permalink to &quot;实际应用中的注意事项&quot;">​</a></h4><ul><li>静态资源缓存: CSS、JS、图片等静态资源可以设置较长的缓存时间。</li><li>动态资源缓存: 经常变动的资源（如登录页面）不宜设置过长的缓存时间。</li><li>浏览器兼容性: 不同浏览器对缓存的处理方式可能存在差异。</li><li>CDN 加速: 内容分发网络（CDN）可以加速资源的传输，提高用户访问速度。</li></ul><h4 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h4><p>HTTP 缓存机制是 Web 性能优化中非常重要的一环。通过合理设置缓存相关的请求头，可以显著提升网页加载速度，改善用户体验。</p>',20)]))}const f=l(d,[["render",c]]);export{_ as __pageData,f as default};
