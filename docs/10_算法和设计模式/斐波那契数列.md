#### 斐波那契数列简介

斐波那契数列是一个经典的递推数列，其数学定义通常为：

- F(0) = 0
- F(1) = 1
- 对于 n ≥ 2，有 F(n) = F(n – 1) + F(n – 2)

也就是说，从第三项开始，每一项都是前两项的和。这个简单的递推关系是实现该算法的核心原理 ​

#### 方法一：递归实现

递归方法直接根据定义编写函数。当 n 为 0 或 1 时直接返回结果；否则调用自身计算 F(n – 1) 与 F(n – 2) 的和。例如：

```js
function fibonacci(n) {
  if (n <= 0) return 0; // 当 n 小于等于0时，返回0
  if (n === 1) return 1; // F(1)=1
  // 递归调用计算 F(n-1) 和 F(n-2)
  return fibonacci(n - 1) + fibonacci(n - 2);
}

// 示例：计算第 10 个斐波那契数
console.log(fibonacci(10)); // 输出 55（F(0)=0, F(1)=1, F(2)=1, F(3)=2, ...）
```

##### 原理解释

递归实现的核心在于“函数调用自身”来解决更小规模的问题。每次调用会将问题规模减小，直到遇到基本情况（n 为 0 或 1）时停止递归，并逐层返回结果。
缺点： 这种方法在 n 较大时会产生大量重复计算（例如计算 fibonacci(5) 时，fibonacci(3) 和 fibonacci(2) 可能被重复求解），导致时间复杂度呈指数级增长

#### 方法二：迭代实现（循环法）

为了避免递归中重复计算的问题，可以采用迭代的方法，从已知的前两个数开始，逐步向前计算出每一项。代码如下：

```js
function fibonacci(n) {
  if (n <= 0) return 0;
  if (n === 1) return 1;

  let a = 0,
    b = 1; // 分别对应 F(0) 和 F(1)
  // 从 2 开始逐项计算
  for (let i = 2; i <= n; i++) {
    let temp = a + b; // 当前项为前两项之和
    a = b; // 更新 a 为前一项
    b = temp; // 更新 b 为当前项
  }
  return b;
}

// 示例：计算第 10 个斐波那契数
console.log(fibonacci(10)); // 输出 55
```

##### 原理解释

该方法利用斐波那契数列的递推公式，从最小子问题开始（已知 F(0) 和 F(1)），依次向前计算。每次循环只保存两个最近的数值，时间复杂度为 O(n) 而空间复杂度仅为 O(1)，因此在大多数实际应用中效率更高

#### 补充：缓存（记忆化）递归

为了兼顾代码的简洁性和递归的直观，可以使用闭包或全局对象来缓存已经计算过的值，从而避免重复计算。示例代码如下：

```js
function fibonacci(n) {
  const memo = {}; // 用于缓存计算结果
  function fib(n) {
    if (n <= 0) return 0;
    if (n === 1) return 1;
    if (memo[n] !== undefined) return memo[n];
    memo[n] = fib(n - 1) + fib(n - 2);
    return memo[n];
  }
  return fib(n);
}

console.log(fibonacci(10)); // 输出 55
```

这种“记忆化”递归将原来指数级的时间复杂度降为 O(n)​

#### 总结

1. 递归方法：实现简单直观，但当 n 较大时会出现大量重复计算，效率较低。
2. 迭代方法：通过循环逐步构造数列，既避免了递归的重复计算问题，又具有较低的时间与空间复杂度，是实际开发中常用的高效实现方案。
3. 记忆化递归：结合递归的直观性和缓存技术，既保持代码简洁，又能大幅提高计算效率。

理解斐波那契数列的本质（每一项等于前两项之和）有助于掌握递归、迭代和动态规划等算法思想 ​
