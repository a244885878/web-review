#### 1. 单例模式

- 原理： 保证一个类（或对象）在整个应用中只有一个实例，并提供全局访问入口。
- 思想： 通过延迟初始化（惰性加载）和实例缓存，避免重复创建同一对象，从而节省资源并保持状态一致。

#### 2. 工厂模式

- 原理： 将对象创建的过程封装在一个单独的“工厂”中，客户端只需通过工厂接口来获取实例，而无需了解对象创建的细节。
- 思想： 通过解耦对象的创建与使用，使得系统具有更高的扩展性和灵活性（例如在不同情况下可以返回不同类型的对象）。

#### 3. 原型模式

- 原理： 以一个已有的对象作为原型，通过复制（克隆）的方式来创建新对象，从而实现属性和方法的共享。
- 思想： 利用 JavaScript 内置的原型链机制，将共享的功能封装在原型上，既节省内存，又方便扩展。

#### 4. 观察者模式

- 原理： 定义一种一对多的依赖关系，使得当一个对象（被观察者）的状态发生变化时，所有依赖它的对象（观察者）都会收到通知并作出响应。
- 思想： 通过“发布—订阅”的方式，实现各组件之间的松耦合通信，常用于数据绑定和事件处理（如 Vue 响应式系统）。

#### 5. 策略模式

- 原理： 将一组可互换的算法封装成独立的策略，使得客户端可以在运行时根据需要选择合适的策略。
- 思想： 将变化的部分（具体算法）与不变的部分（算法调用）分离，便于扩展和维护，同时消除大量条件分支判断。

#### 6. 代理模式

- 原理： 通过为目标对象提供一个代理，来控制对目标对象的访问。代理可以在请求前后加入额外处理（如缓存、延迟加载、权限检查等）。
- 思想： 以中介方式隔离客户端和真实对象，使得在不改变目标对象接口的情况下增强其功能或控制访问。

#### 7. 装饰器模式

- 原理： 动态地为对象添加额外的功能，而不改变其原有的结构。
- 思想： 通过包装原对象，将新功能附加上去，实现功能的扩展和组合，同时保持原有行为不变。

#### 8. 适配器模式

- 原理： 将一个对象的接口转换成客户期望的另一种接口，从而使原本不兼容的对象可以协同工作。
- 思想： 通过封装转换逻辑，屏蔽不同接口间的不匹配，达到复用现有功能和提高系统兼容性的目的。

#### 9. 迭代器模式

- 原理： 为聚合对象提供一种统一的方式顺序访问其内部元素，而不暴露其内部结构。
- 思想： 将遍历逻辑与聚合对象分离，使得无论内部数据结构如何，都可以通过统一接口进行遍历操作。

#### 10. 组合模式

- 原理： 将对象组合成树形结构来表示部分—整体的层次结构，使得客户端可以以一致的方式处理单个对象和组合对象。
- 思想： 通过统一接口和递归处理，简化对复杂结构的操作，方便整体管理和扩展。

> 这些模式的核心原理都围绕着“解耦”、“封装变化”以及“提高代码复用性和可维护性”展开。它们在 JavaScript 中往往会利用语言特性（例如函数是一等公民、原型链继承、闭包等）以更灵活的方式实现，从而满足前端开发中不断变化的业务需求。
